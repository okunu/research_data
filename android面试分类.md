#准备

* 自我介绍,说说自己实习的工作内容；
	* 自备模板

1. 自我介绍？？
	> 
	我是XXX，XXX大学毕业的，已经做了X年的XX开发  
	现在在XX公司，工作内容是：
    	1.负责XX业务和XX功能
    	2.现在的工作内容是XXXX
			因为我是做IM开发的。讲解下用到的技术
    		1.网络保活，通过心跳包（alarmManager）
    		2.IM数据格式采用PB
    		3.数据库使用的是greendao,ORM框架
    		4.用到了设计模式
    		...

2. 为什么要离职？
	> 想换个环境试试看，多学点新的知识(尽量挑好听的来讲)
3. 为什么来我们公司？？
    > 觉得公司现在在做的东西比较对口，并且自己也想往这方面深究。觉得公司技术氛围好,...(这里可以多说点）
4. 在工作中碰到的难点，说明下，怎么解决的？
	>找一个解决了很久的BUG，然后告诉他怎么解决的，为什么解决，吧啦吧啦说一堆应该就好了
5. 最后面试官会问：还有什么想问的
	>就问下公司目前的发展（点到为止就行了）

* 面试杂谈
	* 遇到什么技术难题，你是如何解决的？
		* 一般的人都会遇到一些技术难题，需要平时进行总结归纳，并最好能写成博客的习惯，这样更有说服力；
	* 平常一般看些什么书，或是平时都浏览哪些网站？
		* 这个不要随意发挥，楼主当时在终面时就被问到过，结果楼主傻傻的回答，自己平时会看些文学书，现在回想起来，作为一个技术人员，老板当然希望你是一个钻研技术的好员工，至少你应该答自己平时看些架构方面、性能优化、或是一些该领域牛人出的书。最好有自己的读后感，应用到实际开发中，也可以写成博客的形式。对于平时浏览的网站，也最好答一些跟技术相关的，如csdn、简书、github、stackOverFlow、或是关注的一些牛人、团队、微信公众号等，而不是说自己平时没事刷微博、朋友圈、逛淘宝之类的，老板招的是需要干活的员工，而不是拿着公司钱，让你娱乐。
	* 自己记忆比深刻的文章？
		* 如果你回答没有什么记忆深刻的文章，说明你自己平时看文章都是蜻蜓点水，浅尝辄止，没有深入去研究，网上有那么多好文章，你都没有一篇记忆深刻的么？这就需要咱们平时看别人的文章时，深入思考，发现文章中有哪些写的好地方，哪些写的不好的，如果是自己来写会怎么写，文章有哪些改进之处等。一般文章下面还会有留言区，读者还可以和作者进行互动等。
	* 平时空闲时间都做些什么？
		* 这个也不要随意发挥，当时楼主也很犯二的回答，做饭、锻炼身体和一些其他跟工作八杆子打不着的回答。事后想想对于一个平时都不肯花时间去提升自己的员工，每日只靠工作的那点时间，不去刻意提升自己，这样的人对技术没有什么追求。所以回答时，最好说自己平时会关注当前行业的一些动态，一些大牛写的博客，看看相关专业的书，写写博客，总结总结之类的。

* 说说你的亮点，最值得分享的。
	1. 工作有责任心，有服务精神，比如写一个sdk，会同步写好demo以及文档
	2. 及时总结，乐于分享
*公司的项目，团队情况。
* 面试过程注意：
	>尽量能说的就说,尽量掌握主动权，能够收放自如,碰到不懂的，也不用急，告诉他后续会去查资料等等
* HR面试
	>自然，自然，保持自然就可以了,对她的问题认真回答就行,如果压薪资的话，就看你自己的要求了


* 以后想做Android什么方向？（中间件+SDK）
* 怎么看待前端和后端？
* 项目难点
* 面试建议
	* 多总结现在的项目，即使不是你做的，但是你理解其中的原理，就当作是自己的，反正面试官也不知道
	* 临时抱佛脚也很重要，多看看面试题，多看看源码
	* 不要跟面试官争问题，平心静气的讨论就可以了
	* 跟HR讲条件的时候，自然点，合理就行（有些HR就喜欢压薪资）

* [技术面试九忌](http://www.jianshu.com/p/9099aaed6134)   [备用地址](https://mp.weixin.qq.com/s/luTi1_nCgkzB8XXGVeqizw)

#HR问题汇总
* 您在前一家公司的离职原因是什么？
* 讲一件你印象最深的一件事情；
* 介绍一个你影响最深的项目；
* 介绍你最热爱最擅长的专业领域；
* 公司实习最大的收获是什么；
* 与上级意见不一致时，你将怎么办；
* 自己的优点和缺点是什么？并举例说明？
* 你的学习方法是什么样的？实习过程中如何学习？实习项目中遇到的最大困难是什么以及如何解决的；
* 说一件最能证明你能力的事情；
* 针对你你申请的这个职位，你认为你还欠缺什么；
* 如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办；
* 项目中遇到最大的困难是什么？如何解决的；
* 你的职业规划以及个人目标；未来发展路线及求职定位；
* 如果你在这次面试中没有被录用，你怎么打算；
* 评价下自己，评价下自己的技术水平，个人代码量如何；
* 通过哪些渠道了解的招聘信息，其他同学都投了哪些公司；
* 业余都有哪些爱好；
* 你做过的哪件事最令自己感到骄傲；
* 假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办；
* 就你申请的这个职位，你认为你还欠缺什么；
* 当前的offer状况；如果BATH都给了offer该如何选；
* 你对一份工作更看重哪些方面？平台，技术，氛围，城市，money；
* 理想薪资范围；杭州岗和北京岗选哪个；
* 理想中的工作环境是什么；
* 谈谈你对跳槽的看法；
* 说说你对行业、技术发展趋势的看法；
* 实习过程中周围同事/同学有哪些值得学习的地方；
* 家人对你的工作期望及自己的工作期望；
* 如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办；
* 若上司在公开会议上误会你了，该如何解决；
* 是否可以实习，可以实习多久；
* 在五年的时间内，你的职业规划；
* 你看中公司的什么？或者公司的那些方面最吸引你。

#非技术问题汇总
* 研究比较深入的领域有哪些；
* 对业内信息的关注渠道有哪些；
* 最近都读哪些书；
* 自己最擅长的技术点，最感兴趣的技术领域和技术点；
* 项目中用了哪些开源库，如何避免因为引入开源库而导致的安全性和稳定性问题；
* 实习过程中做了什么，有什么产出；
* 5枚硬币，2正3反如何划分为两堆然后通过翻转让两堆中正面向上的硬币和反面向上的硬币个数相同；
* 时针走一圈，时针分针重合几次；
* N * N的方格纸,里面有多少个正方形；
* 现在下载速度很慢,试从网络协议的角度分析原因,并优化(网络的5层都可以涉及)。
* 为什么离开团队并希望加入什么团队
* 如何学习新技术的
* 项目中遇到的问题及处理方法
* 负责哪块，这里会引发你项目中使用的技术问题
* 擅长什么

#Java知识
* 常见编码方式；utf-8编码中的中文占几个字节；int型几个字节；
* ArrayList 和 LinkedList 的区别？造成区别的原因是什么，为什么删查的复杂度不同； [Android 中的ArrayList & LinkedList](http://www.jianshu.com/p/3d47ad99a18e)
* HashMap深度剖析及相关问题资料(#hashmap_and_others)
* 集合类以及集合框架；HashMap与HashTable实现原理，线程安全性，hash冲突及处理算法；ConcurrentHashMap；
* ArrayList原理，Hashmap 的实现原理是什么；
* HashMap底层实现，hashCode如何对应bucket?
* HashMap，hashtable，currenthashmap等集合的底层实现原理等，扩容，内部结构
* ArrayList和Vector的主要区别是什么？
	* ArrayList在Java1.2引入，用于替换Vector
	* Vector:线程同步,当Vector中的元素超过它的初始大小时，Vector会将它的容量翻倍
	* ArrayList:线程不同步，但性能很好,当ArrayList中的元素超过它的初始大小时，ArrayList只增加50%的大小
* Java 反射了解过没有；反射，注解的原理
* Java GC 了解过没有，如何判断一个对象是否可以被GC;
* 熟不熟jvm，说一下Jvm的自动内存管理？
* jvm运行时数据区域有哪几部分组成，各自作用；(#jvm_area_function)
* gc算法有哪些；gc收集器有哪些；(#gc_suanfa_shoujiqi)
* JVM内存模型及类加载机制；内存对象的循环引用及避免；
* Java的垃圾回收机制，引用计数法两个对象互相引用如何解决？
* 内存回收机制与GC算法(各种算法的优缺点以及应用场景)；GC原理时机以及GC对象；内存泄露场景及解决方法；
* Java 类加载机制了解不，双亲委派原理；
* ClassLoader的基础知识：(#class_loader_about)
* 简述class加载各阶段过程；class loader有哪些模型；(#class_loader)
* 简述常用的JDK命令行工具(#jdk_command)；
* 简述字节码文件的组成(#bytecode_composition)；
* 如何实现一个定时调度和循环调度。(#timer_schedule)；
* 线程
	* Java线程池，线程同步
	* 线程间同步有哪几种(#thread_about)
	* Java 线程同步了解不，同步方法在不同的实例之间是否仍然保持同步，有没有什么隐患；
	* 多线程：如何实现一个定时调度和循环调度的工具类。但提交任务处理不过来的时候，拒绝机制应该如何处理；线程池默认有哪几种拒绝机制；
	* 什么是线程池，如何使用? 答：线程池就是事先将多个线程对象放到一个容器中，当使用的时候就不用new 线程而是直接去池中拿线程即可，节省了开辟子线程的时间，提高的代码执行效率。
	* 数据一致性如何保证；Synchronized关键字，类锁，方法锁，重入锁；
	* 在Java中wait和seelp方法的不同；
		* 答：最大的不同是在等待时wait 会释放锁，而sleep 一直持有锁。wait 通常被用于线程间交互，sleep 通常被用于暂停执行。
	* ThreadLocal原理，实现及如何保证Local属性；
	* 多线程，如何实现一个ThreadLoacl。(#more_thread_impl_ThreadLoacl)
	* 说说你了解的一个线程安全队列。(#thread_safe_queue)
	* 死锁的四个必要条件；
	* 线程池原理，复用，参数的意义等
	* 多线程问题，使用场景，同步，通信，各种锁，死锁问题等
	* 简述AQS。
		* AQS全称为（Abstract Queued Synchronizer），这个类是在java.util.concurrent.locks下面。</br> AQS的核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个就是AQS机制。
	*  简述happen-before规则。
		*  happen-before其实就是一个保证而已，它保证一套语句对内存的写操作对于另一条语句是可见的。</br> 规则
			*  1. 程序顺序规则：一个线程中的每个操作，happen-befor于该线程中的任意后续操作。
			*  2. 监视锁规则：对一个监视器锁的解锁，happen-before于随后对这个监视器锁的加锁。
			*  3. volatileb变量规则：对于一个volatile域的写，happen-before于任意后续对这个volatile域的读。
			*  4. 传递性：如果A happen-before B ，且B happen-before C，那么A happen-before C。
	*  简述synchronized,object,Monitor机制.
		*  synchronized主要是用来进行同步操作，能帮助我们设计更安全的多线程程序。</br> 1)当两个并发线程访问同一个对象object中的synchronized同步代码块时,一个时间内只能有一个线程得到执行。另一个线程只能等到当前线程执行完这个代码块才能执行该代码块。</br> 2）当一个线程访问object的一个synchronized同步代码块时，其他线程对object中所有其它synchronized同步代码块的访问将被阻塞。</br> 3）一个线程访问object中的synchronized代码块时，另外一个线程仍然可以访问object中的其它代码。
			*  对于普通的方法同步，锁是当前实例对象。
			*  对于静态方法同步，锁是当前类的class对象。
			*  对于方法块同步，锁是synchronized括号里的对象。
		* monitor是一个同步工具，相当于操作系统中的互斥量。它内置于每一个object对象中，相当于一个许可证。拿到许可证即可以进行操作，没有拿到需要阻塞等待。
使用synchronized时，其实是通过锁对象的monitor的取用与释放来实现的。
* 断点续传的实现原理(#download_file)
* Http
	* TCP的3次握手和四次挥手；TCP与UDP的区别；
	* HTTP协议；HTTP1.0与2.0的区别；HTTP报文结构；
	* HTTP与HTTPS的区别以及如何实现安全性；
	* tcp和udp的区别，tcp如何保证可靠的，丢包如何处理？
	* tcp和udp的区别，tcp如何保证可靠的，丢包如何处理？tcp的阻塞和超时处理机制等等
	* 谈谈对两类传输协议：TCP、UDP和Socket的理解(#tcp_udp_socket)
	* 为什么TCP是可靠的，UDP早不可靠的?为什么UDP比TCP快?(#why_tcp_fast_udp)
	* 推送心跳包是TCP包还是UDP包或者HTTP包
		* 心跳包的实现是调用了socket.sendUrgentData(0xFF)这句代码实现的，所以，当然是TCP包。
	* Https的工作流程，原理
	* httpResponseCode,例举常见code
	* Http常见问题，协议
	* 谈谈 HTTP 中Get 和 Post 方法的区别(#http_get_post)
	* 移动端获取网络数据优化的几个点(#mobile_http_optimization)
	* 现在下载速度很慢,试从网络协议的角度分析原因,并优化(网络的5层都可以涉及)。

* 如何将一个Java对象序列化到文件里；
* [synchronized与volatile的区别](http://www.jianshu.com/p/ab3ab1049eea)
* 说你对Java反射的理解； 
	* 答：Java 中的反射首先是能够获取到Java 中要反射类的字节码， 获取字节码有三种方法，1.Class.forName(className) 2.类名.class 3.this.getClass()。然后将字节码中的方法，变量，构造函数等映射成相应的Method、Filed、Constructor 等类，这些类提供了丰富的方法可以被我们所使用。
* synchronized 和volatile 关键字的作用
	* 答：1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。2）禁止进行指令重排序。
* volatile 本质是在告诉jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
	1. volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类级别的
	2. volatile 仅能实现变量的修改可见性，并不能保证原子性；synchronized 则可以保证变量的修改可见性和原子性
	3. volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。
	4. volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化
	5. [关于 Java volatile 关键字](https://juejin.im/entry/59b0050ff265da249a203a9d?utm_source=gold_browser_extension)
* switch支持什么类型
	* jdk1.6以及之前版本是byte、char、short、int、枚举 五种
	* jdk1.7时，又增加了String，所以相对于JDK1.7而言就是六种
	* switch支持使用byte类型，不支持long类型，String支持在java1.7引入
* string分析1000次循环subString用了多少内存；
* String StringBuilder StringBuffer对比；
* String StringBuffer StringBuilder说明及区别
	* 字符串是否可改变：
		* String：String中的字符串是固定的，即常量
		* StringBuffer StringBuilde都可改变字符串的长度等,通过.append()方法进行字符串的拼接
	* 线程安全方面：
		* StringBuilder：线程非安全的
		* StringBuffer：线程安全的
	* 执行速度比较：
		* StringBuilder>StringBuffer>String(少量数据其实区别不大)
	* 使用经验：
		1. 操作少量的数据用 ：String
		2. 单线程操作字符串缓冲区 下操作大量数据 ：StringBuilder
		3. 多线程操作字符串缓冲区 下操作大量数据 ：StringBuffer（线程安全）
* 抽象类的意义
	* 为其子类提供一个公共的类型，封装子类中重复的内容，定义抽象方法。子类可有又不同的实现方法，但是定义是一致的
* 内部类的作用
	* 内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立
	* 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口或者继承同一个类
	* 创建内部类对象的时刻并不依赖于外围内对象的创建
	* 内部类没有“is-a”关系，是一个独立的实体
	* 内部类提供了更好的封装，除了该外围类，其他类都不能访问
* 静态内部类、内部类、匿名内部类，为什么内部类会持有外部类的引用？持有的引用是this？还是其它？
	* 静态内部类：使用static修饰的内部类
	* 匿名内部类：使用new生成的内部类
	* 因为内部类的产生依赖于外部类，持有的引用是类名.this。
* 匿名内部类和静态内部类的区别
* Java的四种引用的区别(#java_reference)

* 秒杀功能，如何实现倒计时，本地时间和服务端同步的问题。
	* 参考 [限时抢购秒杀系统架构分析与实战](http://www.jb51.net/article/77560.htm)
* ** [Java面试题集](http://blog.csdn.net/dd864140130/article/details/55833087)
* ** [一个五年Android 开发者百度、阿里、聚美、映客的面试心经](https://www.diycode.cc/topics/165)
* [2016年魅族Android面试题（试答(上)）](http://www.jianshu.com/p/cd9f97853f54)
* [2016年魅族Android面试题（试答(下)）](http://www.jianshu.com/p/596778ae116b)
* 最让我印象深刻的问题是：『你了解过Android上的黑科技么？比如Android 5.0 之上有一个辅助功能，如果用户开启后，就能像豌豆荚那样自动安装app,等同于拥有了root权限，但是手机重启后，这个就自动关闭了，有没有办法可以自动打开呢？』据他了解，有很多不知名的小App 都实现了，但是很多大公司都没用。
	* 我想了好一会，说可能这些app 被厂商列入了白名单，因此重启手机后还能自动打开那个辅助功能。我实在想不出如何能实现这样的效果。最后他告诉我，其实他们也是分析了好久，才发现，那些小App, 都是开启了一个进程（或者是service，具体记不清了，有兴趣的童鞋可以试试）来守护，因此能够开启。这么一说，我也瞬间明白了。

他就问了些职业规划，平时有什么兴趣爱好，以后有什么打算，薪资要多少？我说到公司后可以先接触一些业务层面的东西，然后慢慢再走架构路线，之后可以负责主要核心模块。平时就看看书，参加沙龙活动，没事打打游戏。以后还是要像架构师方向进发的，一个合理的期望薪资。他也简单回答我一些问题。之后就是让我先走，等通知。


#Android基础知识
* Android中ClassLoader和java中有什么关系和区别？
* 内存泄露相关
	* 避免 OOM 的方法(#avoid_oom)；
	* 引起内存泄漏的情况
	* 内存泄漏如何处理及如何排查，LeakCanary原理
	* 图像优化的方法；
	* 一般一个应用手机会分配多少内存
	* 内存泄漏的检测
	* 内存优化
* Activity和Fragment生命周期有哪些？
	* Activity——onCreate->onStart->onResume->onPause->onStop->onDestroy
	* Fragment——onAttach->onCreate->onCreateView->onActivityCreated->onStart->onResume->onPause->onStop->onDestroyView->onDestroy->onDetach
*  Activity和Fragment的区别
	*  一个fragment必须总是嵌入在一个activity中，同时fragment的生命周期受activity而影响，一个Activity可以运行多个 Fragment，一个fragment也可以在多个activity中作为一个模块，fragment有自己的生命周期，接收自己的输入事件，可以从运行中的activity添加或移除。Activity 的后退栈由系统管理，而 Fragment 的后退栈由所在的Activity 管理。
* Activity生命周期，service生命周期(#activity_service_life_cycle)
* 如何理解Activity，View，Window三者之间的关系？(#activity_view_window)
* Activity的几种LaunchMode及使用场景(#LaunchMode)
* activty的加载过程 请详细介绍下:(#activity_load)
* Activity缓存方法：(#activity_cache)
* startActivityForResult是哪个类的方法，在什么情况下使用，如果在Adapter中使用应该如何解耦；
* Fragment相关(#fragment_about)
* Fragment状态保存；
* service启动方式：(#service_boot)
* Service的生命周期，两种启动方法，有什么区别：(#service_start_diff)
* 如何保证Service不被杀死 Android 进程不死?(#service_keep_alive)
* 如何保证一个后台服务不被杀死；比较省电的方式是什么；(见上答案2)
* 请介绍一下ContentProvider是如何实现数据共享的。(#content_provider_how_work)
* 为什么要用 ContentProvider?它和 sql 的实现上有什么差别?(#content_provider_sql)
* 说说 ContentProvider、ContentResolver、ContentObserver 之间的关系(#ContentProvider_ContentResolver_ContentObserver)
* contentProvider 如何传递一个对象
* ApplicationContext和ActivityContext的区别；(#android_application_activity_context)
* Android中的Context, Activity，Appliction有什么区别?(#application_activity_context)
* AsyncTask原理及不足；
* IntentService原理；
* intentservice和service的区别和原理
* SharedPreferences的apply与commit的区别
* Android 事件分发机制了解不，简述一下；及滑动冲突的处理
	* [图解 Android 事件分发机制](http://www.jianshu.com/p/e99b5e8bd67b)
* 请描述一下Android 的事件分发机制；(#android_touch_event)
* Touch事件分发机制；(#android_touch_event_2)	
* 事件分发中的onTouch 和onTouchEvent 有什么区别，又该如何使用？
* onInterceptTouchEvent()和onTouchEvent()的区别？
	* onInterceptTouchEvent()用于拦截触摸事件
	* onTouchEvent()用于处理触摸事件
* 说说ContentProvider、ContentResolver、ContentObserver 之间的关系；
* 请介绍下ContentProvider 是如何实现数据共享的；
* Handler的消息机制；
	* 在整个Handler机制中所有使用到的类，主要包括Message，MessageQueue,Looper以及Handler
	* Handler是Android中引入的一种让开发者参与处理线程中消息循环的机制，Handler直接继承自Object，如果要使用Handler必须先调用Looper.prepare();方法,然后再初始化Handler,之后再调用Looper.loop();方法,每个Handler都关联了一个线程，每个线程内部都维护了一个消息队列MessageQueue，这样Handler实际上也就关联了一个消息队列。这样就可以通过Handler将Message和Runnable对象发送到该Handler所关联线程的MessageQueue（消息队列）中，然后该消息队列通过Looper一直在循环拿出一个Message，对其进行处理，处理完之后拿出下一个Message，继续处理.
	* Handler可以用来在多线程之间进行通信，在另一个线程中去更新UI线程中的UI控件只是Handler使用中的一种典型案例，除此之外，Handler还可以做其他很多的事情，Handler是Thread的代言人，是多线程之间通信的桥梁，通过Handler，我们可以在一个线程中控制另一个线程去做某些事.
	* 具体可参考:[Handler 原理梳理](http://www.jianshu.com/p/0ae0aefe1fc2)
* handler问题
	* 这个需要回复两个基本的，首先handler的创建需要loop，loop怎么创建的，同时这个里面怎么保证loop线程安全的，还有就是消息如何分发的，也就是消息发送到接受的流程，还有callback对消息处理的影响，这些足够了，还可以说可以跨进程，这样就更棒了，具体的在回复说，太多了。
* Handler、Loop消息队列模型，各部分的作用。(#android_handler_loop)
* Handler机制及底层实现；
* Binder机制及底层实现；
* Android IPC:Binder原理(#android_ipc_binder)
* Binder机制(#android_binder)
* 一张Bitmap所占内存以及内存占用的计算；
* 大图片处理(#big_image)
	* 如果图片很大，比如他们的占用内存算下来就直接OOM了，那么我们肯定不能直接加载它。解决主法还是有很多的，系统也给我们提供了一个类BitmapRegionDecoder，可以用来分块加载图片。
* 图片加载的原理，如何压缩图片？
* Bitmap的处理：(#bitmap_about)
* 100×100px，RGB 256 多少kb?
* ARGB_8888占用内存大小
	* 是4byte，即ARGB各占用8个比特来描述。详细解答看这里你的 [Bitmap 究竟占多大内存](http://bugly.qq.com/bbs/forum.php?mod=viewthread&tid=498)    [2](http://dev.qq.com/topic/591d61f56793d26660901b4e)
* 图片圆角处理的方式有哪几种？
* 讲一下android中进程的优先级？
	* 前台进程 可见进程 服务进程 后台进程 空进程
* Serializable 和Parcelable 的区别；
* 如何对Android 应用进行性能分析以及优化；
* 自定义View(#how_define_view)
* 都使用过哪些自定义控件；
* 自定义view viewGroup，以及是否写过，当然还有一些细节问题
* RemoteView在哪些功能中使用
	* APPwidget和Notification中
* SurfaceView和View的最本质的区别?(#surfaceview_and_view)
	* SurfaceView中采用了双缓存技术，在单独的线程中更新界面,View在UI线程中更新界面
* android中有哪几种解析xml的类,官方推荐哪种？以及它们的原理和区别(#android_xml_parse)
* Xml和Json(#xml_and_json)
* 进程间通信，binder
* 性能优化有哪些指标？FPS
* 内存抖动，内存碎片，内存泄露，内存溢出的含义，写一个内存抖动的示例？
* 内存泄露哪几种情况？如何处理？说说检测工具leakCanary
* listview 优化，失帧问题
	1. convertView重用（通过setTag, getTag，获取布局）
	2. ViewHolder优化（避免重复调用findViewById）
	3. 图片加载优化
	4. onClickListener处理
	5. 减少Item View的布局层级
	6. adapter中的getView方法尽量少使用逻辑
	7. adapter中的getView方法尽量少做耗时操作
	8. adapter中的getView方法避免创建大量对象
	9. 将ListView的scrollingCache和animateCache设置为false
	10. 滑动时不加载一些耗资源如图片等，停止时再加载，使用异步加载
* ListView和RecyclerView?(#listview_recycleview)
* ScrollView和ListView事件冲突(见android开发艺术探索)
* ScrollView嵌套ListView, 导致ListView显示不完整，只显示一行
* 数据库批处理失败了如何处理？
	* 使用事务，批量处理，失败会回滚
* 安卓中的布局有哪些，有什么区别，什么场景使用；
* include\ merge\ ViewStub区别，merge要求[android中include、merge、ViewStub使用与源码分析](http://www.jianshu.com/p/5105cc71a3e1)
* 界面卡顿的原因(#ui_cation)
* Android 绘制过程，onMeasure 的原理，解决了什么问题；
* 自定义view viewGroup(#define_view_viewgroup)
* 自定义View相关方法
* View的绘制流程；自定义View如何考虑机型适配；自定义View的事件分发机制；View和ViewGroup分别有哪些事件分发相关的回调方法；自定义View如何提供获取View属性的接口；
* View的绘制流程。(#view_draw_process)
* 安卓view绘制机制和加载过程，请详细说下整个流程(#view_draw_process_2)
* 自定义View如何考虑机型适配(#define_view_adapter)
* View的绘制原理，有没有用canvas自己画过ui？
* 文件和数据库哪个效率高
* [Android屏幕适配方案](http://www.jianshu.com/p/bdbd65928fbf)
* 描述下Aidl？觉得aidl有什么缺陷（这里在这个问题上回答有欠缺）
* Handler消息机制，postDelayed会造成线程阻塞吗？对内存有什么影响？
* Activity的启动模式
* android各版本特性
	* 4.0 截屏功能、全新通知栏
	* 4.4 沉浸式状态栏
	* 5.0 Material design 新的消息通知机制【在锁屏界面也可以直接查看和回复消息】
	* 6.0 新增运行时权限概念，新增瞌睡模式和待机模式，指纹解锁，相机API
	* 7.0 多窗口支持，VR支持
	* 8.0 
* [Android中图片的三级缓存](http://www.jianshu.com/p/2cd59a79ed4a)
* 多进程场景以及所带来的问题
* 多进程场景以及使用场景和常见问题，比如远程回调，数据大小限制，保活机制
* **Android中跨进程通讯有几种方式**
* 多进程通信方式
	* Intent通过bundle发送数据
	* 文件共享
	* content Provider
	* AIDL
	* Messager
	* Socket
* Intent可以传递哪些数据类型
	* 1.Serializable
	* 2.charsequence: 主要用来传递String，char等
	* 3.parcelable
	* 4.Bundle
* MultiDex是怎么实现分包的，它的实现原理，多个dex是怎么加载的
	* [Android MultiDex实现原理解析] [http://www.jianshu.com/p/79a14d340cb0](http://www.jianshu.com/p/79a14d340cb0)
* apk 瘦包机制(#apk_shoushen)
* ddms和traceView的区别
	* ddms：是android开发环境中的dalvik虚拟机调试监控服务；ddms能够提供，测试设备截屏，针对特定的进程查看正在运行的线程以及堆信息，Logcat，广播状态信息，模拟电话呼叫，接收sms，虚拟地理坐标等。
	* traceView是android平台配备的性能分析的工具；它可以通过图形化让我们了解要跟踪的程序的性能，并且能具体到方法。
	* 区别：ddms是一个程序执行查看器，在里面可以看见线程和堆栈等信息，traceView是程序性能分析器。
*  对AIDL的理解
	*  AIDL:android interface definition language的缩写。
	*  AIDL是用来实现进程间通信的，可以帮我们实现发布以及调用远程服务。
	* 使用：
		* 服务端：创建一个Service用来监听客户端的连接请求，然后创建一个AIDL文件，将服务端暴露给客户端的接口在这个文件中声明，最后在Service中实现这个AIDL接口。
		* 客户端：首先绑定服务端的Service，绑定成功后将服务端返回的Binder对象转成AIDL接口所属的类型，接着就可以调用AIDL中的方法。
* Serializable 和Parcelable 的区别(#Serializable_Parcelable)
* 介绍一下NDK;(#introduce_ndk)
* 动画相关
	* Android中的几种动画(#animattion)
	* 动画有哪几类，各有什么特点：(#animattion2)
	* Android全套动画使用技巧   [地址1](https://my.oschina.net/u/2011321/blog/885293)   [备用地址](https://juejin.im/post/58fbfb93a22b9d00659c655f)
* 热修复与插件化
	* 热更新技术简述；
	* 插件化，动态加载
	* 热修复原理 
	* 热修复的原理(#hotfix)
	* 插件化（activity如何加载及资源处理）
	* 组件化
	* 热更新
		* [蘑菇街Android热修复探索之路](http://mp.weixin.qq.com/s/GuzbU1M1LY1VKmN7PyVbHQ)
		* [各大热补丁方案分析和比较](http://blog.zhaiyifan.cn/2015/11/20/HotPatchCompare/)
		* [Android 热修复专题：支付宝、淘宝、微信、QQ空间、饿了么、美丽说蘑菇街、美团大众点评方案集合](https://zhuanlan.zhihu.com/p/25863920?utm_medium=social&utm_source=qq?utm_medium=social&utm_source=qq)
	*  插件化框架描述：dynamicLoadApk为例子
		*  1.可以通过DexClassLoader来对apk中的dex包进行加载访问
		*  2.如何加载资源是个很大的问题，因为宿主程序中并没有apk中的资源，所以调用R资源会报错，所以这里使用了Activity中的实现ContextImpl的getAssets()和getResources()再加上反射来实现。
		*  3.由于系统启动Activity有很多初始化动作要做，而我们手动反射很难完成，所以可以采用接口机制，将Activity的大部分生命周期提取成接口，然后通过代理Activity去调用插件Activity的生命周期。同时如果像增加一个新生命周期方法的时候，只需要在接口中和代理中声明一下就行。
		*  4.缺点：
			*  1.慎用this，因为在apk中使用this并不代表宿主中的activity，当然如果this只是表示自己的接口还是可以的。除此之外可以使用that代替this。
			*  2.不支持Service和静态注册的Broadcast
			*  3.不支持LaunchMode和Apk中Activity的隐式调用。
	*  热修复：Andfix为例子
		*  1.大致原理：apkpatch将两个apk做一次对比，然后找出不同的部分。可以看到生成的apatch了文件，后缀改成zip再解压开，里面有一个dex文件。通过jadx查看一下源码，里面就是被修复的代码所在的类文件,这些更改过的类都加上了一个_CF的后缀，并且变动的方法都被加上了一个叫@MethodReplace的annotation，通过clazz和method指定了需要替换的方法。然后客户端sdk得到补丁文件后就会根据annotation来寻找需要替换的方法。最后由JNI层完成方法的替换。
		*  2.无法添加新类和新的字段、补丁文件很容易被反编译、加固平台可能会使热补丁功能失效
* [Android热更新技术的研究与实现](https://juejin.im/entry/59afb8fc518825243b2a9f7f?utm_source=gold_browser_extension)  [备用地址](http://www.apkbus.com/blog-780485-68702.html)
* 对于应用更新这块是如何做的？(灰度，强制更新，分区域更新)；
* 说说LruCache 底层原理(#LruCache)


#系统方面
* activity的启动流程(#activity_start_mode)
* Activity 的启动过程，Activity 的生命周期什么时候调用的；
* Activity 的生命周期，Back 和 Home 键使用后，生命周期的调用过程；
* Acticity的生命周期，Activity异常退出该如何处理？
* 系统源码分析，例如 Handler、LruCache、Binder等；
* Art和Dalvik对比；
* ART和Dalvik区别? (#art_and_dalvik)
* JVM 和Dalvik虚拟机的区别(#art_and_dalvik)
* 虚拟机原理，如何自己设计一个虚拟机(内存管理，类加载，双亲委派)
* SharedPreference实现
* Android 绘图机制流程原理
* [IPC机制](http://www.jianshu.com/p/282ecb79ba27)
* android重要术语解释(#android_important_word)
* 理解Window和WindowManager(#window_windowManager)


#框架原理
* 项目中用到的框架及原理，比如OkHttp原理，eventbus，butternife等以及是否写过类似的
* 网络框架用的什么，OkHttp 的功能是什么;
* 图片加载库有没有用过，Fresco 的原理，匿名内部共享类的原理；
* 自行设计一个图片加载库的思路；（参照《android开发技术探索》内容）
* Volley 的原理；
* ButterKnife原理(#butterKnife)
* 插件化（activity如何加载及资源处理）(#plugin)
* RxJava+Retrofit
* 开源项目，说说最熟悉的一个。
* glide源码有看过吗，它 支持GIF 图片吗？
* 用过的开源框架的源码分析
* 自己设计一个图片加载框架
* 网络框架的搭建
* 写个图片浏览器，说出你的思路
* Glide的源码
* Okhttp的源码
* Retrofit的源码
* Rxjava的源码
	* Rxjava中的线程切换机制原理
* [okhttp源码解析](http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0326/2643.html)
* [详细图解Fresco的使用](http://blog.csdn.net/y1scp/article/details/49245535)
* [Android图片加载库：最全面解析Glide用法](http://www.jianshu.com/p/c3a5518b58b2)
* 第三方库及实现原理
	* 网络加载
		* 网络请求库（Volley、OkHttp、Retrofit ，android-async-http 的作者已经不维护不讨论）
			* OkHttp 是 Square 公司开源的针对 Java 和 Android 程序，封装的一个高性能 http 请求库，所以它的职责跟 HttpUrlConnection 是一样的，支持 spdy、http 2.0、websocket ，支持同步、异步， OkHttp 还封装了线程池、数据转换、参数使用、错误处理等，api 使用起来更加方便。可以把它理解成是一个封装之后的类似 HttpUrlConnection 的一个东西，但在使用的时候仍然需要自己再做一层封装，这样才能像使用一个框架一样更加顺手。OkHttp 基于 NIO 和 Okio ，所以性能上要比 Volley更快。
			* Volley 是 Google 官方出的一套小而巧的异步请求库，该框架封装的扩展性很强，支持 HttpClient、HttpUrlConnection，甚至支持 OkHttp，但不支持 post 大数据，所以不适合上传文件。Volley 设计的初衷本身也就是为频繁的、数据量小的网络请求而生。
			* Retrofit 是 Square 公司出品的默认基于 OkHttp 封装的一套 RESTful 网络请求框架，通过注解直接配置请求，可以使用不同的 http 客户端，默认是用 http ，可以使用不同 Json Converter 来序列化数据，同时提供对 RxJava 的支持。
		*  OKHttp的优点：
			*  HTTP/2 以及 SPDY的支持多路复用
			*  连接池会降低并发连接数
			*  透明GZIP加密减少下载体积
			*  响应缓存避免大量重复请求
			*  同时支持同步的阻塞式调用与异步回调式调用
		* Retrofit中通过注解方式定义参数、地址、请求方式等，是怎么实现的
		* Retrofit中网络请求框架实现原理
			* 它使用动态代理技术，实现在接口中声明的方法，采用注解方式
			* 参考资料：1)[Android开源项目推荐之「网络请求哪家强」][https://zhuanlan.zhihu.com/p/21879931](https://zhuanlan.zhihu.com/p/21879931) 2)[[Android] Retrofit 2.0实现原理([http://blog.qiji.tech/archives/category/android](http://blog.qiji.tech/archives/category/android))

		* Http头部一般包括哪些内容
		* Http协议相关
			* 总体来说，http协议是从http1.0->http1.1->https-> SPDY->http2.0发展过来的；
			* HTTP1.1相对于HTTP1.0的改进：添加了更多的缓存头策略；宽带优化；优化了错误通知处理；添加了Host头部处理；支持长连接；
			* https相对于http1.x的改进：
				* HTTPS协议需要到CA申请证书；
				* HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的；
				* HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443；
				* HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。
			* SPDY相对于https的改进：
				* 采取了多路复用（multiplexing），降低延迟，还可设置请求的优先级；
				* 请求头部header压缩；服务端推送（server push）；
			* http2.0相对于SPDY的改进：
				* HTTP2.0的协议解析采用二进制格式，更健壮；
				* 优化http请求头部压缩。
			* 参考资料：（[HTTP,HTTP2.0,SPDY,HTTPS你应该知道的一些事](http://www.alloyteam.com/2016/07/httphttp2-0spdyhttps-reading-this-is-enough/)）

		* webview和js相互调用

	* 图片加载库
		* Glide, UniversalImageLoader, Picasso, Fresco区别
			* Glide 默认的 Bitmap 格式是 RGB_565 格式，而 Picasso 默认的是 ARGB_8888 格式，这个内存开销要小一半。
			* 在磁盘缓存方面，Picasso 只会缓存原始尺寸的图片，而 Glide 缓存的是多种规格，也就意味着 Glide 会根据你 ImageView 的大小来缓存相应大小的图片尺寸，比如你 ImageView 大小是200 x 200，原图是 400 x 400 ，而使用 Glide 就会缓存 200 x 200 规格的图，而 Picasso 只会缓存 400 x 400 规格的。这个改进就会导致 Glide 比 Picasso 加载的速度要快，毕竟少了每次裁剪重新渲染的过程。
			* Glide 支持加载 Gif 动态图，而 Picasso 不支持该特性。
			* Fresco 将图片放到一个特别的内存区域叫 Ashmem 区，就是属于 Native 堆，图片将不再占用 App 的内存。
			* 各网络请求库使用线程池情况：
				* Picasso在Wifi下线程数为4,而4G下线程数为3, 3G下为2， 2G下为1，默认状况为3.
				* UniversalImageLoader的加载任务线程池和缓存处理线程池的默认大小都为3，同时默认线程优先级是Thread.NORM_PRIORITY-2,线程池的任务处理类型都是FIFO。
				* Glide加载缓存未命中的线程池会根据根据CPU的数量和Java虚拟机中可用的处理器数量来选择合适的线程数，但是最多不超过4;而加载缓存命中的图片的线程池默认大小为1.
			* 参考资料：
				* [[ Android ] Fresco 与 Picasso 、Glide 的比较] [http://blog.qiji.tech/archives/6344](http://blog.qiji.tech/archives/6344)
				* [Android的App中线程池的使用，具体使用多少个线程池？] [https://www.zhihu.com/question/37804956](https://www.zhihu.com/question/37804956)
				* [Android开源项目推荐之「图片加载到底哪家强」] [https://zhuanlan.zhihu.com/p/21397115](https://zhuanlan.zhihu.com/p/21397115)
				
* Glide是怎么实现图片加载的
	* 它主要采用的技术有：
	* 1. 图片池：(BitmapPool，实现类是LruBitmapPool，是一个基于LRU方式的Bitmap缓存池，用于Bitmap的复用)
	* 2. 两级内存缓存：LruResourceCache， activeResources（先从LruResourceCache中寻找资源，若找到则将其从cache中移除并放入activeResources中，否则从activeResources中寻找。比一般内存缓存额外多一级缓存的意义在于，当内存不足时清理cache中的资源时，不会对使用中的Bitmap造成影响）。
	* 3. 磁盘缓存（若内存中没有，则从磁盘中查找，根据不同的磁盘缓存策略，源数据可首先被写入到磁盘，对获取的Bitmap将其转换然后从缓存文件中加载，而不是直接返回）
	* 4. 网络获取（利用线程池策略，采用okHttp进行请求，并将文件流写入磁盘缓存，再对文件流进行编码）
	* 参考资料 [Glide源码分析] [http://www.jianshu.com/p/96fc561eada1](http://www.jianshu.com/p/96fc561eada1)

	![](http://upload-images.jianshu.io/upload_images/1785727-e6fb64bba8ca78db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
	
* 简单叙述okhttp的实现原理
	* Android中网络请求框架比较多，常用的有HttpURLConnention,Volley，okHttp，Retrofit，RxJava等，从Android4.4开始HttpURLConnection底层实现采用的是okhttp。
进行通信的原理主要是通过dispatcher不断从requestQueue中取出请求call，根据是否已经缓存调用Cache或NetWork这两类数据获取接口之一，从内存缓存或者服务器中获取请求的数据。分为同步和异步请求，同步请求通过call.execute()直接返回当前的response，而异步请求会将当前的call.enqueue添加到请求队列中，通过回调的方式来获取最后的结果。
* 如何实现一个网络框架(参考Volley)
	* 1.缓存队列,以url为key缓存内容可以参考Bitmap的处理方式，这里单独开启一个线程。
	* 2.网络请求队列，使用线程池进行请求。
	* 3.提供各种不同类型的返回值的解析如String，Json，图片等等。


#架构设计
* MVC MVP MVVM; 常见的设计模式；写出观察者模式的代码；
* MVP，MVC，MVVM架构，以Login为例详细说下mvp实现
答：

你常用的设计模式有哪些？
单例模式，如何确保在多线程、多进程获取时确保一致性？
工厂模式
观察者模式

* 七种单例写法及优缺点

* 你所知道的设计模式有哪些； 
	* 答：Java 中一般认为有23 种设计模式，我们不需要所有的都会，但是其中常用的几种设计模式应该去掌握。下面列出了所有的设计模式。需要掌握的设计模式我单独列出来了，当然能掌握的越多越好。
总体来说设计模式分为三大类：
		* 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
		* 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
		* 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。


#优秀文章
* Android 内存泄漏总结(#android_memory_leake)
* 设计模式
	* （1) 单例模式（饿汉式、懒汉式、如何保证线程安全、双重锁机制）
	* （2) 观察者模式（Rxjava中的Observer和Observable、List中的adapter#notifyDataSetChanged()）
	* （3) Builder模式（一般的链式调用，如Glide.with）
	* 参考资料： [从Android代码中来记忆23种设计模式](http://blog.csdn.net/huachao1001/article/details/51536074)


#数据结构与算法
* 单链表判断是否相交、判断是否有环，找出环的第一个结点
* 无序单链表转为有序（快速排序最坏复杂度是多少，最坏复杂度的情景是什么），二叉树判断是否为镜像关系；
* 堆和栈在内存中的区别是什么(数据结构方面以及实际实现方面)；
* 最快的排序算法是哪个？给阿里2万多名员工按年龄排序应该选择哪个算法？堆和树的区别；写出快排代码；链表逆序代码；
* 求1000以内的水仙花数以及40亿以内的水仙花数；
* 子串包含问题(KMP 算法)写代码实现；
* 万亿级别的两个URL文件A和B，如何求出A和B的差集C,(Bit映射->hash分组->多文件读写效率->磁盘寻址以及应用层面对寻址的优化)
* 蚁群算法与蒙特卡洛算法；
* 写出你所知道的排序算法及时空复杂度，稳定性；
* 百度POI中如何试下查找最近的商家功能(坐标镜像+R树)。
* 标号1-n的n个人首尾相接，1到3报数，报到3的退出，求最后一个人的标号
* 给定一个字符串，求第一个不重复的字符 abbcad -> c<!--more-->
* 排序
* 上网站写代码，如下： 有一个容器类 ArrayList，保存整数类型的元素，现在要求编写一个帮助类，类内提供一个帮助函数，帮助函数的功能是删除 容器中<10的元素。
* 写代码，LeetCode上股票利益最大化问题
* 写代码，剑指offer上第一次只出现一次的字符
* 写代码，反转字符串
* 写代码，字符串中出现最多的字符。
* 从一堆数据里怎么查找最大的n个数
* 快速排序
* 字符串匹配
* 自己实现类似stack的功能
* 折半查找
* 链表有关的问题
* [Android面试 · 代码题](http://www.jianshu.com/p/9feb8b52512a)
* 手写猫扑素数的判断
* [Android 面试之编程算法题](http://www.jianshu.com/p/76f87524f855/)
* [牛客网-剑指 Offer](https://www.nowcoder.com/ta/coding-interviews?page=1)
* 排序算法
* 栈和队列
	* 用两个队列实现一个栈，用两个栈实现一个队列
	* 写一个栈的实现代码（用数组实现）
* 判断一个点在一个三角形内
* 排序算法和稳定性，快排什么时候情况最坏?
* 给最外层的rootview，把这个根视图下的全部button背景设置成红色，手写代码，不许用递归
	* 算法原理：
		* Android的view视图是按树形结构分布，所以按树形结构遍历</br>循环判断每一层的ViewGroup元素，将其入栈;否则判断当前view是否是Button类实例，是则改写背景色</br>当前ViewGroup检查childView完成后，判断栈是否非空，取出栈顶元素ViewGroup重复步骤2直至栈为空。
		
		```Java
		void changeAllBtnBGColor(View view, int color) {
		if (view == null || !(view instanceof ViewGroup))
			return; 
		Stack m = new Stack<>();
		while (view != null) { 
			ViewGroup tmpGroup = (ViewGroup) view; 
			int count = tmpGroup.getChildCount(); 
			for (int i = 0; i < count; i++) { View child = tmpGroup.getChildAt(i);
			if (child instanceof ViewGroup) m.add(child); 
			else if (child instanceof Button) { child.setBackgroundColor(color);
		} } 
		if (m.isEmpty()) break; 
		else view = m.pop();
		} 
		}
		```

-------

# Java相关
## <a name="jvm_area_function"/>jvm运行时数据区域有哪几部分组成，各自作用；
jvm运行时数据区通常包括：程序计数器（Program Counter Register）,Java栈（VM Stack）,本地方法栈（Native Method Stack）,方法区（Method Area），堆（Heap）。
###作用：
* **栈：** 栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表，操作数栈，指向当前方法所属的类的运行时常量池的引用，方法返回地址和一些额外的附加信息。当线程执行一个方法时，就会随之创建一个对应的栈帧必定位于java栈的顶部。
* **堆:** 在java中堆是用来存储对象本身的以及数组（数组引用是存放在java栈中的），在java中程序员不用去关心空间释放的问题，java的垃圾回收机制会自动进行处理。因此这部分空间也是java垃圾收集管理的主要区域。堆是被所有线程共享的，在jvm中只有一个堆。
* **方法区：** 方法区在jvm中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称，方法信息，字段信息），静态变量，常量以及编译器编译后的代码等。还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。
* **本地方法栈：**为使用到的本地操作系统方法服务。
* **程序计数器：**一块较小的内存空间，它是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变该计数器的值来选择下一条要执行的字节码指令。分支，跳转，循环等功能都依靠它来实现。每条线程都有一个独立的计数器，它们之间互不影响，因此该区域是线程私有的。

##<a name="gc_suanfa_shoujiqi"/>gc算法有哪些；gc收集器有哪些；
gc是java的垃圾回收机制
###引用计数法（Reference Counting Collector）:
使用计数器来区分存活对象和不再使用的对象。一般来说，堆中的每个对象对应一个引用计数器。当每一次创建一个对象并赋给一个变量时，引用计数器置为1。当对象被赋给任意变量时，引用计数器每次加1当对象出了作用域后(该对象丢弃不再使用)，引用计数器减1，一旦引用计数器为0，对象就满足了垃圾收集的条件。
###标记算法（Tracing Collector):
使用了根集的概念，基于tracing算法的垃圾收集器从根集开始扫描，识别出哪些对象可达，哪些对象不可达，并用某种方式标记可达对象。
###整理算法（Compacting Collecotr）：
该算法会将所有的对象移到堆的一端。能解决堆碎片的问题。
###复制算法：
将内存分为两个区域（from space 和 to space）。所有的对象都分配到from space。清理时先将所有标为活动对象copy到to space，然后清除from space空间。然后互换from space和to apce的身份，每次清理都重复上述过程。

另外一个垃圾回收机制答案

* 标记回收法：遍历对象图并且记录可到达的对象，以便删除不可到达的对象，一般使用单线程工作并且可能产生内存碎片
* 标记-压缩回收法：前期与第一种方法相同，只是多了一步，将所有的存活对象压缩到内存的一端，这样内存碎片就可以合成一大块可再利用的内存区域，提高了内存利用率
* 复制回收法：把现有内存空间分成两部分，gc运行时，它把可到达对象复制到另一半空间，再清空正在使用的空间的全部对象。这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低。
* 分代回收发：把内存空间分为两个或者多个域，如年轻代和老年代，年轻代的特点是对象会很快被回收，因此在年轻代使用效率比较高的算法。当一个对象经过几次回收后依然存活，对象就会被放入称为老年的内存空间，老年代则采取标记-压缩算法


gc收集器：

* **serial收集器：** 单线程，工作时必须暂停其他工作线程，多用于client机器上，使用复制算法。
* **ParNew收集器：** serial的多线程版本，server模式下jvm首选的新生代收集器。复制算法。
* **Parallel Scavenge收集器：** 可控制吞吐量的收集器，吞吐量指有效运行时间。复制算法。
* **Serial Old收集器：** serial的老年代版本，使用整理算法。
* **Parallel Old收集器：** Parallel Scavenge收集器的老版本，多线程，标记整理。
* **CMS收集器：** 整理算法。最短回收停顿时间，缺点是产生碎片。
* **GI收集器：** 基本思想是化整为零，将堆分为多个Region，优先回收价值最大的Region。并行并发，分代收集，空间整合。整理算法。


## <a name="class_loader_about"/>ClassLoader的基础知识：
* 1.双亲委托：一个ClassLoader类负责加载这个类所涉及的所有类，在加载的时候会判断该类是否已经被加载过，然后会递归去他父ClassLoader中找。
* 2.可以动态加载Jar通过URLClassLoader
* 3.ClassLoader 隔离问题 JVM识别一个类是由：ClassLoader id+PackageName+ClassName。
* 4.加载不同Jar包中的公共类：
	* 1.让父ClassLoader加载公共的Jar，子ClassLoader加载包含公共Jar的Jar，此时子ClassLoader在加载公共Jar的时候会先去父ClassLoader中找。(只适用Java)
	* 2.重写加载包含公共Jar的Jar的ClassLoader，在loadClass中找到已经加载过公共Jar的ClassLoader，也就是把父ClassLoader替换掉。(只适用Java)
	* 3.在生成包含公共Jar的Jar时候把公共Jar去掉。

##<a name="class_loader"/>简述class加载各阶段过程；class loader有哪些模型；
在java应用程序开发中，只有被jvm装载的class类型才能在程序中使用。只要生成的字节码符合jvm指令集和文件格式，就可以在jvm上运行，这为java的跨平台性提供条件。
字节码的装载过程分为3个阶段：**加载，连接，初始化**。其中连接包括3个步骤（**验证，准备，解析**）。

* 加载：处于class装载的第一个阶段，这时jvm必须完成通过类的全面获取类的二进制数据流，解析类的二进制数据流为方法区内的数据结构，创建java.lang.Class的实例。
* 连接：
	* 验证：验证字节码文件，保证加载的字节码是符合规范的。
	* 准备：正式为类变量（static修饰的变量）分配内存，并设置内变量的初始值，这些内存都将在方法区进行分配（不包括实例变量）。
	* 解析：将类，接口，方法和字段的应用转为直接引用。
* 初始化：如果前面的步骤都没有出现问题，那么表示类可以顺利的装载到系统中。这个时候才会执行java字节码。初始化阶段的主要工作是执行类的初始化方法。

Class Loader是一个对象，主要是对类的请求提供服务，当jvm需要某个类是它根据名称向ClassLoader请求这个类，然后ClassLoader返回这个类的class对象。

* 引导类加载器（Bootstrap Class Loader）:它用来加载java的核心库，使用源生代码来实现的。
* 扩展类加载器（Extensions Class Loader）:用来加载java的扩展库。jvm的实现会提供一个扩展库目录，该类加载器在目录中寻找并加载java类。
* 系统类加载器（System Class Loader）：一般来讲，java应用的类都是由它加载完成的，是根据java的应用类路径来加载java类。

##<a name="jdk_command"/>简述常用的JDK命令行工具；
jak常用工具在安装目录的bin目录下。

* 工具
	* --编译工具：javac
	* --运行工具：java
	* --压缩工具：jar
	* --文档生成工具：javadoc
	* --字符编码转换工具：native2ascii
*  命令
	*  编译命令
		*  编译一个文件：在目录下面输入javac a.java(java文件名),编译多个文件中间用空格隔开；javac -d cls a.java是讲编译的文件放到同目录的cls文件夹中。
	*  运行命令
		*  java my.hello运行my包下面的hello编译文件。
		*  java -calsspath cl my.java
	*  压缩命令
		*  jar -cvf：压缩 //jar -cvf hello.jar a.class b.class c.class
		*  jar -xvf：解压 //jar -xvf cl\hello.jar 解压cl目录下的hello.jar
	*  文档生成工具
		*  javadoc hello.java
		*  javadoc -d java\doc -version -author lcz\src\lcz.java
	*  字符编码转换工具
		*  native2ascii -encoding 编码 源文件名字 改变后的名字

## <a name="bytecode_composition"/>简述字节码文件的组成；
Class字节码中有两种数据类型：
	
* 字节数据直接量：这是基本的数据类型。共细分为u1、u2、u4、u8四种，分别代表连续的1个字节、2个字节、4个字节、8个字节组成的整体数据
* 表：是有多个基本数据或者其它表，按照规定顺序组成的大的数据集合。

具体详解请参考 [http://www.blogjava.net/DLevin/archive/2011/09/05/358033.html](http://www.blogjava.net/DLevin/archive/2011/09/05/358033.html) （我也不懂 ，自己去看大神写的）。

##<a name="timer_schedule"/>如何实现一个定时调度和循环调度；
使用Timer： 

```Java
Timer myTimer = new Timer(); 
myTimer.schedule(new Worker（），1000)；//1秒后执行。
myTimer.scheduleAtFixedRate(new Worker(),5000,1000);//5秒后执行第一次，之后每隔1秒执行一次。
```


## <a name="thread_about"/>线程间同步有哪几种
###synchronized关键字
由synchronized关键字修饰方法、代码块，如果synchronized修饰的是静态方法，此时若调用该静态方法，将会锁住整修类。使用方法，如饿汉式的线程安全写法（修饰方法）：

```Java
public static synchronized Singleton getInstance() { //锁住获取实例方法
	if (instance == null) {
		instance = new Singleton();
	}
	return instance;
}
```

###用特殊域变量(volatile)实现线程同步
volatile修饰的变量每次都是从内存中读取，而不是从缓存中读取，保证每个线程访问到的变量值都是一样的；适应用于需要读同步的线程同步中，常结合synchronized一起使用。如单例的双重锁写法

```Java
public class Singleton {
	private volatile static Singleton singleton; //使用volatile 关键字
	private Singleton (){} //私有构造函数
	public static Singleton getInstance() {
		if (singleton == null) { //第一层校验
			synchronized (Singleton.class) {
			if (singleton == null) { //第二层校验
				singleton = new Singleton();
			}
		}
	}
	return singleton;
	}
}
```

这里需要使用volatile来修饰单例的实例，因为在执行singleton = new Singleton();这句里需要三步：

1. 给Singleton的实例分配内存；
2. 调用Singleton()的构造函数，需要初始化成员字段；
3. 将singleton对象指向分配的内存空间（即singleton不为空了）；

由于步骤2和步骤3的运行顺序是不确定的，如果某线程创建实例步骤是：1-3-2,在执行3还没有执行2时，另外一个线程就来使用该实例，由于执行了3就直接把实例拿走了，这样在使用过程中就会因为singleton中某些成员没有初始化而报错。

具体的单例写法可参考：[Android设计模式之单例模式的七种写法](http://blog.csdn.net/happy_horse/article/details/51164262)

###使用重入锁ReentrantLock类实现线程同步
用法：先声明一个 ReentrantLock实例
Lock lock = new ReentrantLock();
在需要同步的代码块前后添加上lock.lock()；和lock.unlock()；

###使用ThreadLocal管理变量

* 用ThreadLocal修饰的变量有什么不同？
	* 使用ThreadLocal创建的变量叫线程局部变量，只可以被当前线程访问并修改，其他线程无法访问或修改。若使用ThreadLocal来管理变量，每个线程使用的都是该变量的副本，副本之间是相互独立的，这样每个线程都可以随意修改自己变量的副本，而不会对其他线程产生影响。
* ThreadLocal内部实现原理，怎么保证数据仅被当前线程持有？
	* ThreadLocal在进行放值时的代码如下：
	```Java
	public void set(T value) {
		Thread currentThread = Thread.currentThread();//获取当前线程
		Values values = values(currentThread);//利用当前线程作为句柄获取一个Values对象
		if (values == null) {
			values = initializeValues(currentThread);//values为空则创建一个values对象
		}
		values.put(this, value);//将值放入values对象中
	}
	```

	ThreadLocal的值是放入了当前线程的一个Values实例中，所以只能在本线程访问，其他线程无法访问。

* ThreadLocal修饰的变量一定不能被其他线程访问么？
	* 答案是 **不是**：对于子线程是可以访问父线程中的threadlocal修饰的变量的。
	* 如果在主线程中创建一个InheritableThreadLocal实例，那么在子线程中就可以得到InheritableThreadLocal实例，并获取相应的值。在ThreadLocal中# inheritValues(Values fromParent) 方法来获取父线程中的值。
* ThreadLocal的对象存放在哪？
	* 答案是 **堆上**：在Java中，第个线程都会有一个栈内存，栈内存属于单个线程，其存储的变量只能在其所属线程中可见。但是TheadLocal的值是被线程实例所有，而线程实例是由其创建的类所持有，所以ThreadLocal实例实际上也是被其创建的类所持有，故它们都存在于堆上。
	 
* ThreadLocal会导致内存泄漏么？
	* 答案是　**不会**：虽然ThreadLocal实例被线程中的Values实例所持有，也可以被看成是线程所持有，若使用线程池，之前的线程实例处理完后出于复用的目的依然存在，但Values在选择key时，并不是直接选择ThreadLocal实例，而是ThreadLocal实例的弱引用：</br>
	Reference<ThreadLocal<?>> reference = (Reference<ThreadLocal<?>>) k;</br>
	ThreadLocal<?> key = reference.get();</br>
	在get方法中也是采用弱引用：</br>
	private final Reference<ThreadLocal<T>> reference</br>
		= new WeakReference<ThreadLocal<T>>(this);</br>
	if (this.reference == table[index]) {</br>
		return (T) table[index + 1];</br>
	}</br>
	这样能保证如查当前thread被销毁时，ThreadLocal也会随着销毁被GC回收。

* 在android中的应用
	* android中的looper类就是利用了ThreadLocal特性，保证每个线程只存在一个looper对象。
	
	```Java
	static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();
	private static void prepare(boolean quitAllowed) {
	if (sThreadLocal.get() != null) {
		throw new RuntimeException("Only one Looper may be created per thread");
	}
	sThreadLocal.set(new Looper(quitAllowed));
	}
	```
*  应用场景：
	*  在实现单个线程上下文信息存储，比如交易id等，

##<a name="more_thread_impl_ThreadLoacl"/>多线程，如何实现一个ThreadLoacl
ThreadLoacl，线程安全类。关于线程安全除了synchronized关键字，还有另一种方法就是ThreadLoacl，它通过为每个线程提供一个独立的变量副本，解决了变量并发访问的冲突问题。ThreadLocal比直接使用synchronized更方便，简单并且结果程序拥有更高的并发性。</br>java代码

```Java
private static final ThreadLocal threadSession = new ThreadLocal();    
    
public static Session getSession() throws InfrastructureException {    
    Session s = (Session) threadSession.get();    
    try {    
        if (s == null) {    
            s = getSessionFactory().openSession();    
            threadSession.set(s);    
        }    
    } catch (HibernateException ex) {    
        throw new InfrastructureException(ex);    
    }    
    return s;    
}
```

可以看到在getSession()方法中，首先判断当前线程中有没有放进去session，如果还没有，那么通过sessionFactory().openSession()来创建一个session，再将session set到线程中，实际是放到当前线程的ThreadLocalMap这个map中，这时，对于这个session的唯一引用就是当前线程中的那个ThreadLocalMap，而threadSession作为这个值的key，要取得这个session可以通过threadSession.get()来得到，里面执行的操作实际是先取得当前线程中的ThreadLocalMap，然后将threadSession作为key将对应的值取出。

##<a name="thread_safe_queue"/>说说你了解的一个线程安全队列。
分为BlockingQueQue（阻塞队列）和 ConcurrentLinkedQueQue（非阻塞队列）。</br>以BlockingQueQue为例，BlockingQueQue作为线程容器，可以为线程同步提供有力的保障。</br>
BlockingQueQue有两种实现：

* 基于数组的阻塞队列实现ArrayBlockingQueQue，内部维护了一个定长数组，以便缓存队列中的数据对象。
* 基于链表的阻塞队列LinkedBlockingAQueQue，它内部维护了一个链表结构的数据缓冲队列。
	
BlockingQueQue按照FIFO（先进先出）排列元素。

注意：

* 1，必须要使用take（）方法在获取时达成阻塞结果。
* 2，使用poll（）方法将产生非阻塞效果。

```Java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;



public class BlockingDeque {
//阻塞队列，FIFO
private static LinkedBlockingQueue<Integer> concurrentLinkedQueue = new LinkedBlockingQueue<Integer>(); 


 public static void main(String[] args) {  
 ExecutorService executorService = Executors.newFixedThreadPool(2);  

 executorService.submit(new Producer("producer1"));  
 executorService.submit(new Producer("producer2"));  
 executorService.submit(new Producer("producer3"));  
 executorService.submit(new Consumer("consumer1"));  
 executorService.submit(new Consumer("consumer2"));  
 executorService.submit(new Consumer("consumer3"));  

 }  

 static class Producer implements Runnable {  
 private String name;  

 public Producer(String name) {  
     this.name = name;  
 }  

 public void run() {  
     for (int i = 1; i < 10; ++i) {  
         System.out.println(name+ "  生产： " + i);  
         //concurrentLinkedQueue.add(i);  
         try {
            concurrentLinkedQueue.put(i);
            Thread.sleep(200); //模拟慢速的生产，产生阻塞的效果
            } catch (InterruptedException e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
            }

         }  
     }  
 }  

 static class Consumer implements Runnable {  
 private String name;  

 public Consumer(String name) {  
     this.name = name;  
 }  
 public void run() {  
     for (int i = 1; i < 10; ++i) {  
         try {          
                //必须要使用take()方法在获取的时候阻塞
                  System.out.println(name+"消费： " +  concurrentLinkedQueue.take());  
                  //使用poll()方法 将产生非阻塞效果
                  //System.out.println(name+"消费： " +  concurrentLinkedQueue.poll());  

                 //还有一个超时的用法，队列空时，指定阻塞时间后返回，不会一直阻塞
                 //但有一个疑问，既然可以不阻塞，为啥还叫阻塞队列？
                //System.out.println(name+" Consumer " +  concurrentLinkedQueue.poll(300, TimeUnit.MILLISECONDS));                    
            } catch (Exception e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }  

     }  
     }  
 }  
}
```

##<a name="java_reference"/>Java的四种引用的区别
* **强引用：**如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM 也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象
* **软引用：**在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。
* **弱引用：**具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象
* 虚引用：顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。

##<a name="hashmap_and_others"/>HashMap深度剖析及相关问题资料
原文：[Android面试题----HashMap深度剖析](http://www.jianshu.com/p/bf703c34072b)
###HashMap与HashTable的区别？
主要区别有三点：线程安全性，同步，以及速度。

* HashTable是线程安全的，而HashMap不是；
* HashMap中允许存在null键和null值，而HashTable中不允许
* 单线程环境下HashMap的速度快。多线程环境下，java 5提供了ConcurrentHashmap，它是HashTable的替代，比HashTable的扩展性更好。
###HashMap的工作原理是什么？or HashMap的get()方法工作原理？
HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用LinkedList来解决碰撞问题，当发生碰撞了，对象将会储存在LinkedList的下一个节点中。 HashMap在每个LinkedList节点中储存键值对对象。
###两个对象的hashcode相同时会发生什么？
因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。它们会储存在同一个bucket位置的LinkedList中。键对象的equals()方法用来找到键值对。
###两个键的hashcode相同时，如何获取值对象？
当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。如果有两个值对象储存在同一个bucket，会调用keys.equals()方法遍历LinkedList，直到找到正确的节点，最终找到要找的值对象。
###如果HashMap的大小超过了负载因子定义的容量怎么办？
默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。
###多线程环境下，重新调整HashMap大小存在什么问题？
多线程环境下，当重新调整HashMap大小的时候，存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在LinkedList中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在LinkedList的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。

所在，不能在多线程环境下使用Hashmap。
###为什么String, Interger这样的wrapper类适合作为键？
如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能，也就适合做Hashmap的键。因为获取对象的时候要用到equals()和hashCode()方法，键对象正确的重写这两个方法是非常重要的。

因此，String，Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。
###可以用自定义对象作为键吗？
这是前一个问题的延伸。当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。
###可以使用CocurrentHashMap来代替HashTable吗？
可以。我们知道HashTable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性，效率要低。
###能否让HashMap同步？
Hashmap可以通过下面的语句进行同步：</br>
Map map = Collections.synchronizedMap(hashmap);</br>
Collections 内部有一个实现了 Map 接口的 SynchronizedMap 内部类，这是一个实现线程同步的 map 类，具体线程同步就是在所有的方法实现中都使用 synhronized 块达到线程同步，不过具体的方法实现统统使用 synchronizedMap 方法传递进去 map 来完成。里面的实现是典型的装饰模式。
###ConcurrentHashMap的并发机制？
ConcurrentHashMap 引入了分段锁的机制，该机制对并发控制做了优化 。

ConcurrentHashMap是支持并发读写的HashMap，它的特点是读取数据时无需加锁，写数据时可以保证加锁粒度尽可能的小。由于其内部采用“分段存储”，只需对要进行写操作的数据所在的“段”进行加锁。
ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封装映射表的键 / 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。
通过减小请求同一个锁的频率和尽量减少持有锁的时间 ，使得 ConcurrentHashMap 的并发性相对于 HashTable 和用同步包装器包装的 HashMap有了质的提高。







##<a name="tcp_udp_socket"/>谈谈对两类传输协议：TCP、UDP和Socket的理解
###TCP
TCP是Tranfer Control Protocol的 简称，是一种面向连接的保证可靠传输的协议。通过TCP协议传输，得到的是一个顺序的无差错的数据流。发送方和接收方的成对的两个socket之间必须建 立连接，以便在TCP协议的基础上进行通信，当一个socket（通常都是server socket）等待建立连接时，另一个socket可以要求进行连接，一旦这两个socket连接起来，它们就可以进行双向数据传输，双方都可以进行发送 或接收操作。
###UDP
UDP是User Datagram Protocol的简称，是一种无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。

###比较：
* TCP：
	* 面向连接的协议，在socket之间进行数据传输之前必然要建立连接，所以在TCP中需要连接时间。
	* TCP传输数据大小限制，一旦连接建立起来，双方的socket就可以按统一的格式传输大的数据。
	* TCP是一个可靠的协议，它确保接收方完全正确地获取发送方所发送的全部数据。
* UDP：
	* 每个数据报中都给出了完整的地址信息，因此无需要建立发送方和接收方的连接。
	* UDP传输数据时是有大小限制的，每个被传输的数据报必须限定在64KB之内。
	* UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方

###应用：
* TCP在网络通信上有极强的生命力，例如远程连接（Telnet）和文件传输（FTP）都需要不定长度的数据被可靠地传输。但是可靠的传输是要付出代价的，对数据内容正确性的检验必然占用计算机的处理时间和网络的带宽，因此TCP传输的效率不如UDP高。
* UDP操作简单，而且仅需要较少的监护，因此通常用于局域网高可靠性的分散系统中client/server应用程序。例如视频会议系统，并不要求音频视频数据绝对的正确，只要保证连贯性就可以了，这种情况下显然使用UDP会更合理一些。

###什么是Socket
网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个Socket。Socket通常用来实现客户方和服务方的连接。Socket是TCP/IP协议的一个十分流行的编程界面，一个Socket由一个IP地址和一个端口号唯一确定。</br>
但是，Socket所支持的协议种类也不光TCP/IP一种，因此两者之间是没有必然联系的。在Java环境下，Socket编程主要是指基于TCP/IP协议的网络编程。
###Socket通讯的过程
Server端Listen(监听)某个端口是否有连接请求，Client端向Server 端发出Connect(连接)请求，Server端向Client端发回Accept（接受）消息。一个连接就建立起来了。Server端和Client 端都可以通过Send，Write等方法与对方通信。</br>
对于一个功能齐全的Socket，都要包含以下基本结构，其工作过程包含以下四个基本的步骤：

1.  创建Socket；
2.  打开连接到Socket的输入/出流；
3.  按照一定的协议对Socket进行读/写操作；
4.  关闭Socket.

具体使用可参考:[读懂Java中的Socket编程](http://droidyue.com/blog/2015/03/08/sockets-programming-in-java/)

##<a name="why_tcp_fast_udp"/>为什么TCP是可靠的，UDP早不可靠的?为什么UDP比TCP快?
TCP/IP协议高，因为其拥有三次握手双向机制，这一机制保证校验了数据，保证了他的可靠性。UDP就没有了，udp信息发出后,不验证是否到达对方,所以不可靠。但是就速度来说，还是UDP协议更高，毕竟其无需重复返回验证，只是一次性的

##<a name="http_get_post"/>谈谈 HTTP 中Get 和 Post 方法的区别
GET - 从指定的服务器中获取数据，明文发送内容</br>
POST - 提交数据给指定的服务器处理

1. POST请求不能被缓存下来
2. POST请求不会保存在浏览器浏览记录中
3. 以POST请求的URL无法保存为浏览器书签
4. POST请求没有长度限制

##<a name="mobile_http_optimization"/>移动端获取网络数据优化的几个点

1. 连接复用：节省连接建立时间，如开启 keep-alive。 
对于Android来说默认情况下HttpURLConnection和HttpClient都开启了keep-alive。只是2.2之前HttpURLConnection存在影响连接池的Bug，具体可见：Android HttpURLConnection及HttpClient选择
2. 请求合并：即将多个请求合并为一个进行请求，比较常见的就是网页中的CSS Image Sprites。如果某个页面内请求过多，也可以考虑做一定的请求合并。
3. 减少请求数据的大小：对于post请求，body可以做gzip压缩的，header也可以做数据压缩(不过只支持http 2.0)。
返回数据的body也可以做gzip压缩，body数据体积可以缩小到原来的30%左右。（也可以考虑4. 压缩返回的json数据的key数据的体积，尤其是针对返回数据格式变化不大的情况，支付宝聊天返回的数据用到了）
5. 根据用户的当前的网络质量来判断下载什么质量的图片（电商用的比较多）


##<a name="avoid_oom"/>避免 OOM 的方法
* 使用更加轻量的数据结构
	* 例如，我们可以考虑使用ArrayMap/SparseArray而不是HashMap等传统数据结构。通常的HashMap的实现方式更加消耗内存，因为它需要一个额外的实例对象来记录Mapping操作。另外，SparseArray更加高效，在于他们避免了对key与value的自动装箱(autoboxing)，并且避免了装箱后的解箱。
*  避免在Android里面使用Enum
	* Android官方培训课程提到过“Enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.”，具体原理请参考《Android性能优化典范(三)》，所以请避免在Android里面使用到枚举。
* 减小Bitmap对象的内存占用
	*  Bitmap是一个极容易消耗内存的大胖子，减小创建出来的Bitmap的内存占用可谓是重中之重，，通常来说有以下2个措施： ++inSampleSize++：缩放比例，在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。 ++decode format++：解码格式，选择ARGB_6666/RBG_545/ARGB_4444/ALPHA_6，存在很大差异
* Bitmap对象的复用
	*  缩小Bitmap的同时，也需要提高BitMap对象的复用率，避免频繁创建BitMap对象，复用的方法有以下2个措施 LRUCache : “最近最少使用算法”在Android中有极其普遍的应用。ListView与GridView等显示大量图片的控件里，就是使用LRU的机制来缓存处理好的Bitmap，把近期最少使用的数据从缓存中移除，保留使用最频繁的数据， inBitMap高级特性:利用inBitmap的高级特性提高Android系统在Bitmap分配与释放执行效率。使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的Bitmap会尝试去使用之前那张Bitmap在Heap中所占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放Bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小
* 使用更小的图片
	* 在涉及给到资源图片时，我们需要特别留意这张图片是否存在可以压缩的空间，是否可以使用更小的图片。尽量使用更小的图片不仅可以减少内存的使用，还能避免出现大量的InflationException。假设有一张很大的图片被XML文件直接引用，很有可能在初始化视图时会因为内存不足而发生InflationException，这个问题的根本原因其实是发生了OOM。
*  StringBuilder 
	*  在有些时候，代码中会需要使用到大量的字符串拼接的操作，这种时候有必要考虑使用StringBuilder来替代频繁的“+”。
*  避免在onDraw方法里面执行对象的创建
	*  类似onDraw等频繁调用的方法，一定需要注意避免在这里做创建对象的操作，因为他会迅速增加内存的使用，而且很容易引起频繁的gc，甚至是内存抖动。
* 避免对象的内存泄露

##<a name="activity_service_life_cycle"/>Activity生命周期，service生命周期
![](../images/mianshi/service_life_cycle.png)
![](../images/mianshi/activity_life_cycle.png)
![](../images/mianshi/fragment_life_cycle.png)

##<a name="activity_view_window"/>如何理解Activity，View，Window三者之间的关系？
这个问题真的很不好回答。所以这里先来个算是比较恰当的比喻来形容下它们的关系吧。Activity像一个工匠（控制单元），Window像窗户（承载模型），View像窗花（显示视图）LayoutInflater像剪刀，Xml配置像窗花图纸。

1. Activity构造的时候会初始化一个Window，准确的说是PhoneWindow。
2. 这个PhoneWindow有一个“ViewRoot”，这个“ViewRoot”是一个View或者说ViewGroup，是最初始的根视图。
3. “ViewRoot”通过addView方法来一个个的添加View。比如TextView，Button等
4. 这些View的事件监听，是由WindowManagerService来接受消息，并且回调Activity函数。比如onClickListener，onKeyDown等。

##<a name="LaunchMode"/>Activity的几种LaunchMode及使用场景
###standard 模式
这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。使用场景：大多数Activity。
###singleTop 模式
如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。使用场景如新闻类或者阅读类App的内容页面。
###singleTask 模式
如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。使用场景如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。
###singleInstance 模式
在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。使用场景如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -> B (singleInstance) -> C，完全退出后，在此启动，首先打开的是B。
###android:taskAffinity属性
android:taskAffinity是Activity的一个属性，表示该Activity期望的任务栈的名称。默认情况下，一个应用程序中所有Activity的taskAffinity都是相同的，即应用程序的包名。当然，我们可以在配置文件中为每个Activity指定不同的taskAffinity（只有和已有包名不同，才有意义）。一般情况下，该属性主要和SingleTask启动模式或者android:allowTaskReparenting属性结合使用，在其他情况下没有意义。

##<a name="activity_load"/>activty的加载过程 请详细介绍下:

1. Activity中最终到startActivityForResult()（mMainThread.getApplicationThread()传入了一个ApplicationThread检查APT）
->Instrumentation#execStartActivity()和checkStartActivityResult()(这是在启动了Activity之后判断Activity是否启动成功，例如没有在AM中注册那么就会报错)
->ActivityManagerNative.getDefault().startActivity()（类似AIDL，实现了IAM，实际是由远端的AMS实现startActivity()）
->ActivityStackSupervisor#startActivityMayWait()
->ActivityStack#resumeTopActivityInnerLocked
->ActivityStackSupervisor#realStartActivityLocked()（在这里调用APT的scheduleLaunchActivity,也是AIDL，不过是在远端调起了本进程Application线程）
->ApplicationThread#scheduleLaunchActivity()（这是本进程的一个线程，用于作为Service端来接受AMS client端的调起）
->ActivityThread#handleLaunchActivity()（接收内部类H的消息，ApplicationThread线程发送LAUNCH_ACTIVITY消息给H）
->最终在ActivityThread#performLaunchActivity()中实现Activity的启动完成了以下几件事：
2. 从传入的ActivityClientRecord中获取待启动的Activity的组件信息
3. 创建类加载器，使用Instrumentation#newActivity()加载Activity对象
4. 调用LoadedApk.makeApplication方法尝试创建Application，由于单例所以不会重复创建。
5. 创建Context的实现类ContextImpl对象，并通过Activity#attach()完成数据初始化和Context建立联系，因为Activity是Context的桥接类，最后就是创建和关联window，让Window接收的事件传给Activity，在Window的创建过程中会调用ViewRootImpl的performTraversals()初始化View。
6. Instrumentation#callActivityOnCreate()->Activity#performCreate()->Activity#onCreate().onCreate()中会通过Activity#setContentView()调用PhoneWindow的setContentView()更新界面。

##<a name="activity_cache"/>Activity缓存方法：
1. 配置改变导致Activity被杀死，横屏变竖屏：在onStop之前会调用onSaveInstanceState()保存数据在重建Activity之后，会在onStart()之后调用onRestoreInstanceState(),并把保存下来的Bundle传给onCreate()和它会默认重建Activity当前的视图，我们可以在onCreate()中，回复自己的数据。
2. 内存不足杀掉Activity，优先级分别是：前台可见，可见非前台，后台。

##<a name="fragment_about"/>Fragment相关
###Fragment 如何实现类似 Activity 栈的压栈和出栈效果的?
Fragment 的事物管理器内部维持了一个双向链表结构，该结构可以记录我们每次 add 的Fragment 和 replace 的 Fragment，然后当我们点击 back 按钮的时候会自动帮我们实现退栈操作。
###Fragment 在你们项目中的使用
Fragment 是 android3.0 以后引入的的概念，做局部内容更新更方便，原来为了到达这一点要把多个布局放到一个 activity 里面，现在可以用多 Fragment 来代替，只有在需要的时候才加载Fragment，提高性能。
###Fragment 的好处：
1. Fragment 可以使你能够将 activity 分离成多个可重用的组件，每个都有它自己的生命周期和UI。
2. Fragment 可以轻松得创建动态灵活的 UI 设计，可以适应于不同的屏幕尺寸。从手机到平板电脑。
3. Fragment 是一个独立的模块,紧紧地与 activity 绑定在一起。可以运行中动态地移除、加入、交换等。
4. Fragment 提供一个新的方式让你在不同的安卓设备上统一你的 UI。
5. Fragment 解决 Activity 间的切换不流畅，轻量切换。
6. Fragment 替代 TabActivity 做导航，性能更好。
7. Fragment 在 4.2.版本中新增嵌套 fragment 使用方法，能够生成更好的界面效果
8. 如何切换 fragement,不重新实例化
	1. 正确的切换方式是 add()，切换时 hide()，add()另一个 Fragment;再次切换时，只需 hide()当前show()另一个

##<a name="animattion"/>Android中的几种动画
曾被问到Android中有几种动画，这个问题也好难回答。Android3.0之前有2种，3.0后有3种。

* **FrameAnimation（逐帧动画）：**将多张图片组合起来进行播放，类似于早期电影的工作原理，很多App的loading是采用这种方式。
* **TweenAnimation（补间动画）：**是对某个View进行一系列的动画的操作，包括淡入淡出（Alpha），缩放（Scale），平移（Translate），旋转（Rotate）四种模式。
* **PropertyAnimation（属性动画）：**属性动画不再仅仅是一种视觉效果了，而是一种不断地对值进行操作的机制，并将值赋到指定对象的指定属性上，可以是任意对象的任意属性。

[http://blog.csdn.net/yanbober/article/details/46481171](http://blog.csdn.net/yanbober/article/details/46481171)

##<a name="animattion2"/>动画有哪几类，各有什么特点：
动画的基本原理：其实就是利用插值器和估值器，来计算出各个时刻View的属性，然后通过改变View的属性来，实现View的动画效果。

* View动画:只是影像变化，view的实际位置还在原来的地方。
* 帧动画是在xml中定义好一系列图片之后，使用AnimationDrawable来播放的动画。
* View的属性动画：
	* 1.插值器：作用是根据时间的流逝的百分比来计算属性改变的百分比
	* 2.估值器：在1的基础上由这个东西来计算出属性到底变化了多少数值的类

##<a name="hotfix"/>热修复的原理
1：JavaSisst
2：AspectJ
3：Xposef
这里给出Xposef方案
[http://mp.weixin.qq.com/s?__biz=MzA3Mjk1MjA4Nw==&mid=400452659&idx=1&sn=841b49b875ec3b307f261ed52a7d9c4e&scene=23&srcid=1119JWRt0adNwGxTHiyok460#rd](http://mp.weixin.qq.com/s?__biz=MzA3Mjk1MjA4Nw==&mid=400452659&idx=1&sn=841b49b875ec3b307f261ed52a7d9c4e&scene=23&srcid=1119JWRt0adNwGxTHiyok460#rd)


##<a name="surfaceview_and_view"/>SurfaceView和View的最本质的区别?
SurfaceView是在一个新起的单独线程中可以重新绘制画面，而view必须在UI的主线程中更新画面。
在UI的主线程中更新画面可能会引发问题，比如你更新的时间过长，那么你的主UI线程就会被你正在画的函数阻塞。
那么将无法响应按键、触屏等消息。当使用SurfaceView由于是在新的线程中更新画面所以不会阻塞你的UI主线程。
但这也带来了另外一个问题，就是事件同步。比如你触屏了一下，你需要SurfaceView中thread处理，一般就需要有一个event queue的设计来保存touchevent，这会稍稍复杂一点，因为涉及到线程安全。

##<a name="define_view_viewgroup"/>自定义view viewGroup
这个就是约定的几个方法,onMeasure,onLayout,onDraw,measure,layout,draw
同时注意写方法的调用时机以及区别,比如onMeasure是个模版方法是在measure下调用的,这个方法在viewGroup里面,自定义的这些就已经足够了，如果还扩展一些更新问题，子线程能不能更新，是可以的,在ViewRootImpl没创建之前可以更新，不同sdk这个类可能名字不一样。

1. 自定义属性
2. onLayout(Viewgroup)
3. onMesure
4. onDraw
5. 交互:onIntercepterTouchEvent()onTouchEvent()

## 自定义view的步骤
1. 确定是完全自定义还是继承View的派生子类
2. 定义自定义属性，在资源元素<declare-styleable>中为您的view定义自定义属性。
3. 获取自定义属性，当view从XML布局中创建了之后，XML标签中所有的属性都从资源包中读取出来并作为一个AttributeSet传递给view的构造函数。
4. 添加属性和事件
5. 自定义绘制（实施）,重写onDraw()\onMesure()方法，如果是viewGroup，还需要重写onLayout()方法

##<a name="content_provider_how_work"/>请介绍一下ContentProvider是如何实现数据共享的。
Android提供了ContentProvider，一个程序可以通过实现一个ContentProvider的抽象接口将自己的数据完全暴露出去，而且ContentProvicer是以类似数据库中表的方式将数据暴露。也就是说ContentProvider就像一个“数据库”。那么外界获取其提供的数据，也就应该与从数据库中获取数据的操作基本一样，只不过是采用URI来表示外界需要访问的“数据库”。外部访问通过ContentResolver去访问并操作这些被暴露的数据。

##<a name="content_provider_sql"/>为什么要用 ContentProvider?它和 sql 的实现上有什么差别?
* ContentProvider 屏蔽了数据存储的细节,内部实现对用户完全透明,用户只需要关心操作数据的uri 就可以了，ContentProvider 可以实现不同 app 之间共享。
* Sql 也有增删改查的方法，但是 sql 只能查询本应用下的数据库。而 ContentProvider 还可以去增删改查本地文件. xml 文件的读取等。

##<a name="ContentProvider_ContentResolver_ContentObserver"/>说说 ContentProvider、ContentResolver、ContentObserver 之间的关系
* ContentProvider 内容提供者，用于对外提供数据
* ContentResolver.notifyChange(uri)发出消息
* ContentResolver 内容解析者，用于获取内容提供者提供的数据
* ContentObserver 内容监听器，可以监听数据的改变状态
* ContentResolver.registerContentObserver()监听消息。

##<a name="android_memory_leake"/>引起内存泄漏的情况
* 对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销。
* 静态内部类持有外部成员变量（或context）:可以使用弱引用或使用ApplicationContext。
* 内部类持有外部类引用,异步任务中，持有外部成员变量。
* 集合中没用的对象没有及时remove。不用的对象及时释放，如使用完Bitmap后掉用recycle（），再赋null。
* handler引起的内存泄漏，MessageQueue里的消息如果在activity销毁时没有处理完，就会引起内存的泄漏，可以使用弱引用解决。
* 设置过的监听不用时，及时移除。如在Destroy时及时remove。尤其以addListener开头的，在Destroy中都需要remove。

activity泄漏可以使用LeakCanary。

###内存优化 ，如何避免oom
内存优化太多要说的了，有套路的回答，基本就是避免跟gc配合好工作.
比如：尽量复用对象，处理无用对象，避免内存泄漏，压缩对象等等.
尽量将大对象特殊处理，比如bitmap占用内存较多，可以jni层与java层配合一起，大小压缩，质量压缩，imsimplesize的大小定义，规范等等，程序中有内存管理模块，避免内存压力大的时候
，能够释放内存，避免oom发生的几率，还有很多方面，在评论回复吧。

###内存泄漏如何处理及如何排查
内存泄漏最大的问题就是无用对象常驻内存，导致内存压力很大，最后可能导致oom发生。

尽量将对象生命周期可以在控制的能力之内，也很多场景,比如：context 除了特殊情况用activity，其他我们没理由不用application。
排查导出堆空间，然后mat分析，程序里面用leackcanary定位。

[Android面试——APP性能优化](http://yuweiguocn.github.io/android-interview-peformance/)
[Android常见问题之内存溢出（OOM）](http://www.jianshu.com/p/e9a741f477fc)
[Android常见问题之内存泄漏](http://www.jianshu.com/p/d0414f94b127)

##<a name="android_xml_parse"/>android中有哪几种解析xml的类,官方推荐哪种？以及它们的原理和区别
* DOM解析
	* 优点:
		1. XML树在内存中完整存储,因此可以直接修改其数据和结构.
		2. 可以通过该解析器随时访问XML树中的任何一个节点.
		3. DOM解析器的API在使用上也相对比较简单.
	* 缺点:
		1. 如果XML文档体积比较大时,将文档读入内存是非常消耗系统资源的.
	* 使用场景:
		1. DOM 是用与平台和语言无关的方式表示 XML 文档的官方 W3C 标准.
		2. DOM 是以层次结构组织的节点的集合.
		3. 这个层次结构允许开发人员在树中寻找特定信息.分析该结构通常需要加载整个文档和构造层次结构,然后才能进行任何工作.DOM是基于对象层次结构的.
* SAX解析
	* 优点:
		* SAX 对内存的要求比较低,因为它让开发人员自己来决定所要处理的标签.特别是当开发人员只需要处理文档中所包含的部分数据时,SAX 这种扩展能力得到了更好的体现.
	* 缺点:
		* 用SAX方式进行XML解析时,需要顺序执行,所以很难访问到同一文档中的不同数据.此外,在基于该方式的解析编码过程也相对复杂.
	* 使用场景:
		* 对于含有数据量十分巨大,而又不用对文档的所有数据进行遍历或者分析的时候,使用该方法十分有效.该方法不用将整个文档读入内存,而只需读取到程序所需的文档标签处即可.

* Xmlpull解析
	* android SDK提供了xmlpull api,xmlpull和sax类似,是基于流（stream）操作文件,然后根据节点事件回调开发者编写的处理程序.因为是基于流的处理,因此xmlpull和sax都比较节约内存资源,不会象dom那样要把所有节点以对橡树的形式展现在内存中.xmlpull比sax更简明,而且不需要扫描完整个流.

##<a name="xml_and_json"/>Xml和Json
###XML
* XML的优点
	* 格式统一，符合标准；
	* 容易与其他系统进行远程交互，数据共享比较方便。
* XML的缺点
	* XML文件庞大，文件格式复杂，传输占带宽；
	* 服务器端和客户端都需要花费大量代码来解析XML，导致服务器端和客户端代码变得异常复杂且不易维护；
	* 客户端不同浏览器之间解析XML的方式不一致，需要重复编写很多代码
	* 服务器端和客户端解析XML花费较多的资源和时间。
* 解析方式:
	* DOM解析器
	* SAX解析器
	* PULL解析器
	
	PULL解析器小巧轻便，解析速度快，简单易用，非常适合在Android移动设备中使用，Android系统内部在解析各种XML时也是用PULL解析器。主要使用XmlPullParser这个类.

###Json
* JSON的优点：
	* 数据格式比较简单，易于读写，格式都是压缩的，占用带宽小；
	* 易于解析，客户端JavaScript可以简单的通过eval()进行JSON数据的读取；
	* 支持多种语言，包括ActionScript, C, C#, ColdFusion, Java, JavaScript, Perl, PHP, Python, Ruby等服务器端语言，便于服务器端的解析；
	* 在PHP世界，已经有PHP-JSON和JSON-PHP出现了，偏于PHP序列化后的程序直接调用，PHP服务器端的对象、数组等能直接生成JSON格式，便于客户端的访问提取；
	* 因为JSON格式能直接为服务器端代码使用，大大简化了服务器端和客户端的代码开发量，且完成任务不变，并且易于维护。
* JSON的缺点
	* 没有XML格式这么推广的深入人心和喜用广泛，没有XML那么通用性；
	* JSON格式目前在Web Service中推广还属于初级阶段。
* 解析方式:
	* 传统的使用JSONObject进行解析
	* Gson
	* FastJson
* XML和JSON的优缺点对比
	* 可读性方面。
		* JSON和XML的数据可读性基本相同，JSON和XML的可读性可谓不相上下，一边是建议的语法，一边是规范的标签形式，XML可读性较好些。
	* 可扩展性方面。
		* XML天生有很好的扩展性，JSON当然也有，没有什么是XML能扩展，JSON不能的。
	* 编码难度方面。
		* XML有丰富的编码工具，比如Dom4j、JDom等，JSON也有json.org提供的工具，但是JSON的编码明显比XML容易许多，即使不借助工具也能写出JSON的代码，可是要写好XML就不太容易了。
	* 解码难度方面。
		* XML的解析得考虑子节点父节点，让人头昏眼花，而JSON的解析难度几乎为0。这一点XML输的真是没话说。
	* 流行度方面。
		* XML已经被业界广泛的使用，而JSON才刚刚开始，但是在Ajax这个特定的领域，未来的发展一定是XML让位于JSON。到时Ajax应该变成Ajaj(Asynchronous Javascript and JSON)了。
	* 解析手段方面。
		* JSON和XML同样拥有丰富的解析手段。
	* 数据体积方面。
		* JSON相对于XML来讲，数据的体积小，传递的速度更快些。
	* 数据交互方面。
		* JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
	* 数据描述方面。
		* JSON对数据的描述性比XML较差。
	* 传输速度方面。
		* JSON的速度要远远快于XML。


##<a name="service_boot"/>service启动方式:
	* 1. startService() -----stopService() 或者 selfStop() 结束service
	* 2. bingService() -----另外一种 bindService() 方法的意思是，把这个 Service 和调用 Service 的客户类绑起来，如果调用这个客户类被销毁，Service 也会被销毁。用这个方法的一个好处是，bindService() 方法执行后 Service 会回调上边提到的 onBind() 方发，你可以从这里返回一个实现了 IBind 接口的类，在客户端操作这个类就能和这个服务通信了，比如得到 Service 运行的状态或其他操作。如果 Service 还没有运行，使用这个方法启动 Service 就会 onCreate() 方法而不会调用 onStart()。

###1.直接启动的方式
startService启动服务，stopService停止服务。</br>
完整生命周期回调顺序为：onCreate -> onStartCommand -> onDestroy
有效生命周期为：onStartCommand和onDestroy之间</br>
onCreate 创建服务时回调。onCreate只会调用一次</br>
onStartCommand 启动服务时回调。一旦启动，服务即可在后台运行，即使启动服务的组件已被销毁也不受影响。每次调用startService()时都会回调，允许多次调用。 传参startId是请求的id唯一标识，其返回值描述系统应该如何在服务终止的情况下继续运行服务，是对系统的要求。

返回值取值为：

* **START_NOT_STICKY** 如果系统在 onStartCommand() 返回后终止服务，则除非有挂起 Intent 要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。
* **START_STICKY** 如果系统在 onStartCommand() 返回后终止服务，则会重建服务并调用 onStartCommand()，但绝对不会重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务（在这种情况下，将传递这些 Intent ），否则系统会通过空 Intent 调用 onStartCommand()。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。
* **START_REDELIVER_INTENT** 如果系统在 onStartCommand() 返回后终止服务，则会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。

onDestroy 停止服务时回调。此方法用来清理所有资源，如线程、注册的侦听器、接收器等。需要调用stopSelf(int)或stopService()停止服务。当有多个请求时，stopSelf(int) 确保服务停止请求始终基于最近的启动请求id，服务才能停止，否则服务会继续运行。

###2.绑定的方式
bindService绑定服务，unbindService解绑服务。</br>
完整生命周期回调顺序为：onCreate -> onBind -> onUnbind -> onDestroy
有效生命周期为：onBind和onUnbind之间</br>
**onCreate** 创建服务时回调。onCreate只会调用一次</br>
**onBind** 绑定服务时回调。绑定服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 (IPC) 跨进程执行这些操作，如果不允许绑定，则应返回null。 仅当与另一个应用组件绑定时，绑定服务才会运行。 多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。只有在第一个客户端绑定时，系统才会调用服务的 onBind() 方法来检索 IBinder，系统随后无需再次调用 onBind()，便可将同一 IBinder 传递至任何其他绑定的客户端。该方法不一定在UI线程。</br>
**onUnbind** 解绑服务时回调。当所有客户端都与Service断开连接时调用。默认返回false，当返回值为true时，后续有新Client绑定时会回调onRebind()</br>
**onRebind** 重新绑定时回调。onUnbind()返回true，且有新Client绑定时调用</br>
**onDestroy** 停止服务时回调。此方法用来清理所有资源，如线程、注册的侦听器、接收器等。服务与所有客户端之间的绑定全部取消时，系统便会销毁它

绑定方式详细生命周期图:

![](../images/mianshi/service_bind_life_cycle.png)

##<a name="service_start_diff"/>Service的生命周期，两种启动方法，有什么区别：
* 1.context.startService() ->onCreate()- >onStart()->Service running-->(如果调用context.stopService() )->onDestroy() ->Service shut down
	* 1.如果Service还没有运行，则调用onCreate()然后调用onStart()；
	* 2.如果Service已经运行，则只调用onStart()，所以一个Service的onStart方法可能会重复调用多次。
	* 3.调用stopService的时候直接onDestroy，
	* 4.如果是调用者自己直接退出而没有调用stopService的话，Service会一直在后台运行。该Service的调用者再启动起来后可以通过stopService关闭Service。
* 2.context.bindService()->onCreate()->onBind()->Service running-->onUnbind() -> onDestroy() ->Service stop
	*  1.onBind将返回给客户端一个IBind接口实例，IBind允许客户端回调服务的方法，比如得到Service运行的状态或其他操作。
	*  2.这个时候会把调用者和Service绑定在一起，Context退出了,Service就会调用onUnbind->onDestroy相应退出。
	*  3.所以调用bindService的生命周期为：onCreate --> onBind(只一次，不可多次绑定) --> onUnbind --> onDestory。

## <a name="service_keep_alive"/>如何保证Service不被杀死 Android 进程不死?
* 提供进程优先级，降低进程被杀死的概率
	* 方法一：监控手机锁屏解锁事件，在屏幕锁屏时启动1个像素的 Activity，在用户解锁时将 Activity 销毁掉。
	* 方法二：启动前台service。
	* 方法三：提升service优先级：在AndroidManifest.xml文件中对于intent-filter可以通过
android:priority = "1000"//这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时适用于广播。
*  在进程被杀死后，进行拉活。
	* 方法一：注册高频率广播接收器，唤起进程。如网络变化，解锁屏幕，开机等
	* 方法二：双进程相互唤起。
	* 方法三：依靠系统唤起。
	* 方法四：onDestroy方法里重启service：service +broadcast 方式，就是当service走ondestory的时候，发送一个自定义的广播，当收到广播的时候，重新启动service；
* 依靠第三方根据终端不同。
在小米手机（包括 MIUI）接入小米推送、华为手机接入华为推送；其他手机可以考虑接入腾讯信鸽或极光推送与小米推送做 A/B Test。

* 联系厂商，加入白名单

参考博客：
[http://www.jianshu.com/p/d0a4ce3a3b65](http://www.jianshu.com/p/d0a4ce3a3b65)
[Android 进程保活招式大全](http://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&mid=2653577617&idx=1&sn=623256a2ff94641036a6c9eea17baab8&scene=0#wechat_redirect)  </br>
[Activity、Application以及BroadcastReceiver生命周期](http://www.jianshu.com/p/e6b38a3f0364)
</br>
[http://www.jianshu.com/p/fcac1a8437ba](http://www.jianshu.com/p/fcac1a8437ba)

答案2

Android中通过Service实现后台任务。

* 方法一：
	* 通过将Service绑定到Notification，成为一个前提服务，可以提高存活率在Service中创建一个Notification，再调用Service.startForeground(int id,Notification notification)方法运行在前台即可。这个方式使用360等如阿健管家可以杀死。
* 方法二：
	* 通过定时警报来不断启动Service，这样就算Service被杀死，也能再启动。同时也可以监听网络切换，开锁屏等广播启动Service。  参考：</br>
	Intent intent = new Intent（mContext，MyService.class）；</br>
	PendingIntent sender = PendingIntent.getService(mContext,0,intent,0);</br>
	AlarmManager alarm = (AlarmManager)getSystemService(ALARM_SERVICE);</br>
	alarm.setRepeating(AlarmManager.RTC_WAKEUP,System.currentTimeMillis(),5*10000,sender);</br>这种方式不断启动的逻辑处理起来很麻烦。
* 方法三：
	* 通过jni调用c，在c语音中启动一个进程fork（）。 可以保证360等手机管家不会清理。但是带来了jni交互，稍微有点麻烦。




##<a name="listview_recycleview"/>ListView和RecyclerView?
ListView和RecycleView的缓存原理大致相同，都是在内部维护一个缓存池，回收划出列表的item，添加给将要进入列表的item。只不过ListView内部是两级缓存，分别是mActiveViews和mScrapViews.而RecycleView内部有四级缓存。
###ListView相比RecyclerView，有一些优点：
1. addHeaderView(), addFooterView()添加头视图和尾视图。
2. 通过”android:divider”设置自定义分割线。
3. setOnItemClickListener()和setOnItemLongClickListener()设置点击事件和长按事件。

这些功能在RecyclerView中都没有直接的接口，要自己实现（虽然实现起来很简单），因此如果只是实现简单的显示功能，ListView无疑更简单。

###RecyclerView相比ListView，有一些明显的优点：
1. 默认已经实现了View的复用，不需要类似if(convertView == null)的实现，而且回收机制更加完善。
2. 默认支持局部刷新。
3. 容易实现添加item、删除item的动画效果。
4. 容易实现拖拽、侧滑删除等功能。
5. DiffUtil可用于高效进行RecyclerView的数据更新。
6. RecyclerView是一个插件式的实现，对各个功能进行解耦，从而扩展性比较好.

具体可参考以下几篇文章:

[Android ListView与RecyclerView对比浅析--缓存机制](https://segmentfault.com/a/1190000007331249)

[RecyclerView 必知必会](http://mp.weixin.qq.com/s/CzrKotyupXbYY6EY2HP_dA)

[使用DiffUtil高效更新RecyclerView](http://blog.chengdazhi.com/index.php/231)

##<a name="big_image"/>大图片处理
###压缩
BitmapFactory这个类提供了多个解析方法(**decodeByteArray, decodeFile, decodeResource**等)用于创建Bitmap对象，我们应该根据图片的来源选择合适的方法。比如SD卡中的图片可以使用decodeFile方法，网络上的图片可以使用decodeStream方法，资源文件中的图片可以使用decodeResource方法。这些方法会尝试为已经构建的bitmap分配内存，这时就会很容易导致OOM出现。

为此每一种解析方法都提供了一个可选的BitmapFactory.Options参数，将这个参数的inJustDecodeBounds属性设置为true就可以让解析方法禁止为bitmap分配内存，返回值也不再是一个Bitmap对象，而是null。虽然Bitmap是null了，但是BitmapFactory.Options的outWidth、outHeight和outMimeType属性都会被赋值。这个技巧让我们可以在加载图片之前就获取到图片的长宽值和MIME类型，从而根据情况对图片进行压缩。如下代码所示：

```Java
BitmapFactory.Options options = new BitmapFactory.Options();  
options.inJustDecodeBounds = true;  
BitmapFactory.decodeResource(getResources(), R.id.myimage, options);  
int imageHeight = options.outHeight;  
int imageWidth = options.outWidth;  
String imageType = options.outMimeType;
```

现在图片的大小已经知道了，我们就可以决定是把整张图片加载到内存中还是加载一个压缩版的图片到内存中。以下几个因素是我们需要考虑的：

1. 预估一下加载整张图片所需占用的内存。
2. 为了加载这一张图片你所愿意提供多少内存。
3. 用于展示这张图片的控件的实际大小。
4. 当前设备的屏幕尺寸和分辨率。

通过设置BitmapFactory.Options中inSampleSize的值就可以实现对图片进行压缩.下面的方法可以根据传入的宽和高，计算出合适的inSampleSize值：

```Java
public static int calculateInSampleSize(BitmapFactory.Options options,  
    int reqWidth, int reqHeight) {  
    // 源图片的高度和宽度  
    final int height = options.outHeight;  
    final int width = options.outWidth;  
    int inSampleSize = 1;  
    if (height > reqHeight || width > reqWidth) {  
        // 计算出实际宽高和目标宽高的比率  
        final int heightRatio = Math.round((float) height / (float) reqHeight);  
        final int widthRatio = Math.round((float) width / (float) reqWidth);  
        // 选择宽和高中最小的比率作为inSampleSize的值，这样可以保证最终图片的宽和高  
        // 一定都会大于等于目标的宽和高。  
        inSampleSize = heightRatio < widthRatio ? heightRatio : widthRatio;  
    }  
    return inSampleSize;  
}
```

使用这个方法，首先你要将BitmapFactory.Options的inJustDecodeBounds属性设置为true，解析一次图片。然后将BitmapFactory.Options连同期望的宽度和高度一起传递到到calculateInSampleSize方法中，就可以得到合适的inSampleSize值了。之后再解析一次图片，使用新获取到的inSampleSize值，并把inJustDecodeBounds设置为false，就可以得到压缩后的图片了。

```Java
public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId,  
    int reqWidth, int reqHeight) {
    // 第一次解析将inJustDecodeBounds设置为true，来获取图片大小  
    final BitmapFactory.Options options = new BitmapFactory.Options();  
    options.inJustDecodeBounds = true;  
    BitmapFactory.decodeResource(res, resId, options);  
    // 调用上面定义的方法计算inSampleSize值  
    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);  
    // 使用获取到的inSampleSize值再次解析图片  
    options.inJustDecodeBounds = false;  
    return BitmapFactory.decodeResource(res, resId, options);  
}
```

###缓存
内存缓存技术对那些大量占用应用程序宝贵内存的图片提供了快速访问的方法。其中最核心的类是LruCache (此类在android-support-v4的包中提供) 。这个类非常适合用来缓存图片，它的主要算法原理是把最近使用的对象用强引用存储在 LinkedHashMap 中，并且把最近最少使用的对象在缓存值达到预设定值之前从内存中移除。

下面是一个使用 LruCache 来缓存图片的例子：

```Java
private LruCache<String, Bitmap> mMemoryCache;  

@Override  
protected void onCreate(Bundle savedInstanceState) {  
    // 获取到可用内存的最大值，使用内存超出这个值会引起OutOfMemory异常。  
    // LruCache通过构造函数传入缓存值，以KB为单位。  
    int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);  
    // 使用最大可用内存值的1/8作为缓存的大小。  
    int cacheSize = maxMemory / 8;  
    mMemoryCache = new LruCache<String, Bitmap>(cacheSize) {  
        @Override  
        protected int sizeOf(String key, Bitmap bitmap) {  
            // 重写此方法来衡量每张图片的大小，默认返回图片数量。  
            return bitmap.getByteCount() / 1024;  
        }  
    };  
}  

public void addBitmapToMemoryCache(String key, Bitmap bitmap) {  
    if (getBitmapFromMemCache(key) == null) {  
        mMemoryCache.put(key, bitmap);  
    }  
}  

public Bitmap getBitmapFromMemCache(String key) {  
    return mMemoryCache.get(key);  
}

```

当向 ImageView 中加载一张图片时,首先会在 LruCache 的缓存中进行检查。如果找到了相应的键值，则会立刻更新ImageView ，否则开启一个后台线程来加载这张图片。

```Java
public void loadBitmap(int resId, ImageView imageView) {  
    final String imageKey = String.valueOf(resId);  
    final Bitmap bitmap = getBitmapFromMemCache(imageKey);  
    if (bitmap != null) {  
        imageView.setImageBitmap(bitmap);  
    } else {  
         imageView.setImageResource(R.drawable.image_placeholder);  
         BitmapWorkerTask task = new BitmapWorkerTask(imageView);  
         task.execute(resId);  
    }  
}

```

BitmapWorkerTask 还要把新加载的图片的键值对放到缓存中。

```Java
class BitmapWorkerTask extends AsyncTask<Integer, Void, Bitmap> {  
    // 在后台加载图片。  
    @Override  
    protected Bitmap doInBackground(Integer... params) {  
        final Bitmap bitmap = decodeSampledBitmapFromResource(  
            getResources(), params[0], 100, 100);  
        addBitmapToMemoryCache(String.valueOf(params[0]), bitmap);  
        return bitmap;  
    }  
}
```

具体可参考: [Android高效加载大图、多图解决方案，有效避免程序OOM](http://blog.csdn.net/guolin_blog/article/details/9316683)

##<a name="bitmap_about"/>Bitmap的处理：
* 1.当使用ImageView的时候，可能图片的像素大于ImageView，此时就可以通过BitmapFactory.Option来对图片进行压缩，inSampleSize表示缩小2^(inSampleSize-1)倍。
* 2.BitMap的缓存：
	* 1.使用LruCache进行内存缓存。
	* 2.使用DiskLruCache进行硬盘缓存。
	* 3.实现一个ImageLoader的流程：同步异步加载、图片压缩、内存硬盘缓存、网络拉取
		* 1.同步加载只创建一个线程然后按照顺序进行图片加载
		* 2.异步加载使用线程池，让存在的加载任务都处于不同线程
		* 3.为了不开启过多的异步任务，只在列表静止的时候开启图片加载


##<a name="download_file"/>断点续传的实现原理
其实断点续传的原理很简单，从字面上理解，所谓断点续传就是从停止的地方重新下载。

* 断点：线程停止的位置。
* 续传：从停止的位置重新下载。

用代码解析就是：

* 断点 ： 当前线程已经下载完成的数据长度。
* 续传 ： 向服务器请求上次线程停止位置之后的数据。

原理知道了，功能实现起来也简单。每当线程停止时就把已下载的数据长度写入记录文件，当重新下载时，从记录文件读取已经下载了的长度。而这个长度就是所需要的断点。

续传的实现也简单，可以通过设置网络请求参数，请求服务器从指定的位置开始读取数据。

而要实现这两个功能只需要使用到**httpURLconnection**里面的**setRequestProperty**方法便可以实现.

```Java
public void setRequestProperty(String field, String newValue)
```

使用:

```Java
conn.setRequestProperty("Range", "bytes=" + startIndex + "-" + endIndex);
```

具体使用:

```Java
public class MutilDownloader {
    // 开启的线程的个数
    public static final int THREAD_COUNT = 3;
    public static int runningThread = 3;// 记录正在运行的下载文件的线程数
    public static void main(String[] args) throws Exception {
        String path = "文件下载地址";
        // 1、连接服务器，获取一个文件，获取文件的长度，在本地创建一个大小跟服务器文件大小一样的临时文件
        URL url = new URL(path);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.setConnectTimeout(5000);
        conn.setRequestMethod("GET");
        int code = conn.getResponseCode();
        if (code == 200) {
            // 服务器返回的数据的长度，实际就是文件的长度
            int length = conn.getContentLength();
            System.out.println("----文件总长度----" + length);
            // 在客户端本地创建出来一个大小跟服务器端文件一样大小的临时文件
            RandomAccessFile raf = new RandomAccessFile("temp.apk", "rwd");
            // 指定创建的这个文件的长度
            raf.setLength(length);
            // 关闭raf
            raf.close();
            // 假设是3个线程去下载资源
            // 平均每一个线程下载的文件的大小
            int blockSize = length / THREAD_COUNT;
            for (int threadId = 1; threadId <= THREAD_COUNT; threadId++) {
                // 第一个线程开始下载的位置
                int startIndex = (threadId - 1) * blockSize;
                int endIndex = threadId * blockSize - 1;
                if (threadId == THREAD_COUNT) {
                    endIndex = length;
                }
                System.out.println("----threadId---" + "--startIndex--"
                    + startIndex + "--endIndex--" + endIndex);
                new DownloadThread(path, threadId, startIndex, endIndex).start();
            }
        }
    }
    /**
     * 下载文件的子线程，每一个线程下载对应位置的文件
     * 
     * @author loonggg
     * 
     */
    public static class DownloadThread extends Thread {
        private int threadId;
        private int startIndex;
        private int endIndex;
        private String path;
        /**
         * @param path
         *            下载文件在服务器上的路径
         * @param threadId
         *            线程id
         * @param startIndex
         *            线程下载的开始位置
         * @param endIndex
         *            线程下载的结束位置
         */
        public DownloadThread(String path, int threadId, int startIndex,int endIndex) {
            this.path = path;
            this.threadId = threadId;
            this.startIndex = startIndex;
            this.endIndex = endIndex;
        }

        @Override
        public void run() {
            try {
                // 检查是否存在记录下载长度的文件，如果存在读取这个文件的数据
                File tempFile = new File(threadId + ".txt");
                if (tempFile.exists() && tempFile.length() > 0) {
                    FileInputStream fis = new FileInputStream(tempFile);
                    byte[] temp = new byte[1024 * 10];
                    int leng = fis.read(temp);
                    // 已经下载的长度
                    String downloadLen = new String(temp, 0, leng);
                    int downloadInt = Integer.parseInt(downloadLen);
                    startIndex = downloadInt;
                    fis.close();
                }
                URL url = new URL(path);
                HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                conn.setRequestMethod("GET");
                // 重要：请求服务器下载部分的文件 指定文件的位置
                conn.setRequestProperty("Range", "bytes=" + startIndex + "-" + endIndex);
                conn.setConnectTimeout(5000);
                // 从服务器请求全部资源的状态码200 ok 如果从服务器请求部分资源的状态码206 ok
                int code = conn.getResponseCode();
                System.out.println("---code---" + code);
                InputStream is = conn.getInputStream();// 已经设置了请求的位置，返回的是当前位置对应的文件的输入流
                RandomAccessFile raf = new RandomAccessFile("temp.apk", "rwd");
                // 随机写文件的时候从哪个位置开始写
                raf.seek(startIndex);// 定位文件
                int len = 0;
                byte[] buffer = new byte[1024];
                int total = 0;// 记录已经下载的数据的长度
                while ((len = is.read(buffer)) != -1) {
                    RandomAccessFile recordFile = new RandomAccessFile(threadId+ ".txt", "rwd");// 记录每个线程的下载进度，为断点续传做标记
                    raf.write(buffer, 0, len);
                    total += len;
                    recordFile.write(String.valueOf(startIndex + total)
                        .getBytes());
                    recordFile.close();
                }
                is.close();
                raf.close();
                System.out.println("线程：" + threadId + "下载完毕了！");
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                runningThread--;
                if (runningThread == 0) {// 所有的线程已经执行完毕
                    for (int i = 1; i <= THREAD_COUNT; i++) {
                        File file = new File(i + ".txt");
                        file.delete();
                    }
                }
            }
        }
    }
}

```
具体可参考:[多线程系列之多线程下载之断点续传（2）](http://godcoder.me/2016/04/20/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E4%B9%8B%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%EF%BC%882%EF%BC%89/)

##<a name="how_define_view"/>自定义View
可分为三类:

* 自定义View，——继承 View，然后自绘视图内容
* 自定义ViewGroup，——继承ViewGroup，然后对子类视图进行重新布局。
* 自定义已有View，——继承已有的View，比如继承ImageView

这里介绍下自定义视图的主要步骤:

1. 自定义属性
2. 继承View重写构造方法
3. 获取自定义属性
4. 重写测量控件的宽高
5. 绘制控件显示
6. 提供自定义事件

###1. 自定义属性
自定义属性一共有10中定义类型，String，boolean等，具体的类型
和使用对应如下代码:

``xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <attr name="text" format="string"></attr>
    <!--
    定义：资源ID
    使用：@drawable/图片ID
    -->
    <attr name="msrc" format="reference"></attr>
    <!--
    定义: 颜色值
    使用: android:mcolor = "#00FF00"
    -->
    <attr name="mcolor" format="color"></attr>
    <!--
    定义：布尔类型
    使用：android:misfocus = "true"
    -->
    <attr name="misfocus" format="boolean"></attr>
    <!--
    定义：尺寸
    使用： android:msize = "42dip"
    -->
    <attr name="msize" format="dimension"></attr>
    <!--
    定义：浮点值
    使用： android:malpha = "0.1"
    -->
    <attr name="malpha" format="float"></attr>
    <!--
    定义：整形
    使用：android:mcount = "12"
    -->
    <attr name="mcount" format="integer"></attr>
    <!--
    定义：字符串
    使用：android:apiKey = "2223"
    -->
    <attr name="apikey" format="string"></attr>
    <!--
    定义：百分数
    使用：100%
    -->
    <attr name="mcurrent" format="fraction"></attr>
    <!--
    定义：枚举

    使用：type:1
    -->
    <attr name="type">
        <enum name="cycle" value="1"></enum>
        <enum name="round" value="2"></enum>
    </attr>
    <declare-styleable name="customView">
        <attr name="text"/>
        <attr name="mcolor"/>
        <attr name="msize"/>
    </declare-styleable>
</resources>
```

###2. 创建自定义View继承View（重写构造方法）
在创建View的时候，需要重写构造方法，一般重写前三个构造方法就可以了，但是如果我们的自定控件是通过布局文件的形式加载，则第二个构造必须重写，不然会报错。

```Java
public MyCuntomView(Context context) {
    this(context, null);
}

public MyCuntomView(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
}

public MyCuntomView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);

    //获取自定义属性
    initViewAtrr(context, attrs, defStyleAttr);
}

```

###3. 获取自定属性的值
在获取自定义属性值的时候，我们通过循环的方式来获取值，这样获取到属性值，就是我们xml文件中使用到的，没有使用到的就获取不到。而并获取我们所有自定义的属性。

```Java
private void initViewAtrr(Context context, AttributeSet attrs, int defStyleAttr) {

    TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.customView, defStyleAttr, 0);

    //获取有几个自定义属相
    final int count = a.getIndexCount();
    Log.e("TAG", "=====" + count);

    for (int i = 0; i < count; i++) {
        int type = a.getIndex(i);
        switch (type) {
            case R.styleable.customView_text:

                text = a.getString(type);
                if (TextUtils.isEmpty(text)) {
                    text = "我是文本";
                }
                break;

            case R.styleable.customView_mcolor:

                corlor = a.getColor(type, Color.RED);

                break;

            case R.styleable.customView_msize:

                msize = a.getDimensionPixelSize(type, 15);
                break;

        }

    }

    a.recycle();

    paint = new Paint();
    //抗锯齿
    paint.setAntiAlias(true);


}
```

###4.测量控件的大小（重写onMeasure方法）
测量之前先了解MeasureSpec的specMode,mode共有三种情况，取值分别为MeasureSpec.UNSPECIFIED, MeasureSpec.EXACTLY, MeasureSpec.AT_MOST。

>MeasureSpec.EXACTLY是精确尺寸，当我们将控件的layout_width或layout_height指定为具体数值时如andorid:layout_width=”50dp”，或者为FILL_PARENT是，都是控件大小已经确定的情况，都是精确尺寸。

>MeasureSpec.AT_MOST是最大尺寸，当控件的layout_width或layout_height指定为WRAP_CONTENT时，控件大小一般随着控件的子空间或内容进行变化，此时控件尺寸只要不超过父控件允许的最大尺寸即可。因此，此时的mode是AT_MOST，size给出了父控件允许的最大尺寸。

>MeasureSpec.UNSPECIFIED是未指定尺寸，这种情况不多，一般都是父控件是AdapterView，通过measure方法传入的模式。

```Java
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {

    int mode = MeasureSpec.getMode(widthMeasureSpec);
    int size = MeasureSpec.getSize(widthMeasureSpec);
    bounds = new Rect();
    if (mode == MeasureSpec.EXACTLY) {
        mwidth = size;
    } else {

        paint.setTextSize(msize);

        paint.getTextBounds(text, 0, text.length(), bounds);
        mwidth = getPaddingLeft() + getPaddingRight() + bounds.width();

    }


    mode = MeasureSpec.getMode(heightMeasureSpec);
    size = MeasureSpec.getSize(heightMeasureSpec);
    if (mode == MeasureSpec.EXACTLY) {

        mheight = size;
    } else {

        paint.getTextBounds(text, 0, text.length(), bounds);
        mheight = getPaddingBottom() + getPaddingTop() + bounds.height();
    }

  r=Math.max(mwidth,mheight);
    setMeasuredDimension(r, r);

}
```

###5.绘制控件显示（重写onDraw方法）
以下代码是绘制一个圆并绘制文字:

```Java
@Override
protected void onDraw(Canvas canvas) {
    paint.setColor(corlor);
    canvas.drawCircle(r/2,r/2,r/2,paint);
    paint.setColor(Color.BLACK);
    canvas.drawText(text,r/2-bounds.width()/2,r/2+bounds.height()/2,paint);

}

```

###6.定义事件
一些根据手势操作的代码可以写在此处

```Java
@Override
public boolean onTouchEvent(MotionEvent event) {

    //手势操作相关代码
         ...
         ...
    return super.onTouchEvent(event);
}
```

###7.编写自定义控件，使用自定义属性
编写自定义控件，使用自定义属性,在跟布局添加如下代码:

```xml
 xmlns:app="http://schemas.android.com/apk/res-auto"
```

并以以下方式引用控件:

```xml
包名.MyCuntomView
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    app:xxx="xxx"
    app:xxx="xxx"
    app:xxx="xxx" />

```

完成以上步骤后,Activity和Fragment就可以使用相应的控件来实现相应的交互.


具体可参考:[Android 自定义View（基础）](http://blog.csdn.net/baidu_31956557/article/details/53355208)


##<a name="ui_cation"/>界面卡顿的原因
Android系统每隔16ms会发出信号重绘我们的界面(Activity).**为什么是16ms, 因为Android设定的刷新率是60FPS(Frame Per Second), 也就是每秒60帧的刷新率, 约合16ms刷新一次**.

例如, 假设我们更新屏幕的背景图片, 需要24ms来做这次运算. 当系统在第一个16ms时刷新界面, 然而我们的运算还没有结束, 无法绘出图片. 当系统隔16ms再发一次VSYNC信息重绘界面时, 用户才会看到更新后的图片. 也就是说用户是32ms后看到了这次刷新(注意, 并不是24ms). 这就是传说中的丢帧(dropped frame),丢帧给用户的感觉就是卡顿, 而且如果运算过于复杂, 丢帧会更多, 导致界面常常处于停滞状态, 卡到爆.

###原因
* 过于复杂的布局(UI布局层次太深,即布局嵌套太多了, 或是自定义控件的onDraw中有复杂运算)
* 过度绘制(Overdraw) ：绘制了多重背景.绘制了不可见的UI元素.
* UI线程的复杂运算
* 频繁的GC
	* 执行GC操作的时候，任何线程的任何操作都会需要暂停，等待GC操作完成之后，其他操作才能够继续运行, 故而如果程序频繁GC, 自然会导致界面卡顿.
	
 具体参考:[Android App优化之消除卡顿](http://www.jianshu.com/p/1fb065c806e6)

##<a name="apk_shoushen"/>apk 瘦包机制
![](http://upload-images.jianshu.io/upload_images/1785727-2b7202c62d8422ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

上图是一般的apk包包含的文件，如果加入混淆等还会有proguard.cfg、project.properties等文件，从图中可以看出AndroidManifest.xml、META-INF这些本身就很小没有必要做进一步压缩的文件，而其它文件或者文件夹都可以考虑进行优化，从而减小APK的体积。下面具体说说android apk

* 使用lint去除一些无用的代码、资源减小resources.arsc体积
	* 可以借助Android Studio→Inspect Code...对工程做静态代码检查，删掉无用的代码；
* 代码混淆减少classes.dex大小
	* 代码混淆可以减小该文件的大小，因为混淆后的代码将较长的文件名、实例、变量、方法名等等做了简化，从而实现字节长度上的优化；
* 压缩资源：
	* 使用一些小图片代替大图，有些适配图片可能只需要保留一套如xxhdpi，有些背景图片用代码实现，用.9.png；
	* 使用tinypng压缩图片；
	*  对图片质量要求不是很严格，可以考虑不带alpha值的jpg图片、同等质量下文件更小的webP图片格式；
	*  借助微信提供的AndResGuard资源文件混淆工具对资源文件做混淆，进一步压缩资源文件所占用的空间；
*  去掉一些不用的适配
	* 如果只需要支持中文，可在build.grade中添加resConfigs "zh"去除无用的语言资源；
	* 去掉一些so包支持   
		* 一种CPU架构 = 一种ABI = 一种对应的SO库；
		* 现在手机市场总共支持以下七种不同的CPU架构：ARMv5，ARMv7，x86，MIPS，ARMv8，MIPS64和x86_64, 这7种CPU类型对应的SO库的文件夹名是：armeabi，armeabi-v7a，x86，mips，arm64-v8a，mips64，x86_64。所有的x86/x86_64/armeabi-v7a/arm64-v8a设备都支持armeabi架构的.so文件，64位设备（arm64-v8a, x86_64, mips64）能够运行32位的函数库，所以应用不需要支持很多设备，建议实际工作的配置是只保留armable、armable-x86下的so文件，当然so包是向下兼容的，如果提供了其他cpu类型的文件夹，也需要在相应的文件夹里补全所有的so包，要不手机到时适配找不到合适的so包导致crash
* 减小或甚用第三方依赖库
	*  如果只使用第三方依赖库的少部分功能，可以考虑只提取少部分代码，而不是直接把第三库全部引入；
	*  用较少的库替换大库；
*  插件化和动态加载
	*  上面提到的so包，可以只提供一套，在应用运行时，需要用到so包的地方，可以从服务器下载so包，再动态加载；
* [如何做到将apk大小减少6M](http://blog.csdn.net/cantus_hjk/article/details/50678154)
* [Android动态加载] [http://www.jianshu.com/p/e9da13f647a9](http://www.jianshu.com/p/e9da13f647a9)


## <a name="view_draw_process"/>View的绘制流程
View的绘制是从ViewRoot的performTraversals（）方法开始的，经过measure，layout，draw这个3大步骤。

###measure的过程：
measure过程是对整个view树的所有控件计算宽高</br>measure是冲ViewRoot类中的host.measure开始的，内部调用的是View的measure（int widthMeasureSpec,int heightMeasureSpec）方法，</br>measure方法里面调用了onMeasure（int widthMeasureSpec,int heightMeasureSpec）方法，方法中的两个参数都是是MeasureSpec类型（指父控件对子控件宽高的期望值，它是一个32位的int类型数，前两位表示测量模式，后30位表示测量大小）</br>测量模式一共有3种：

* EXACTLY 精确测量模式，xml文件中写200dp，march_parent等代表使用该模式，
* AT_MOST 最大模式，xml文件中写wrap_content表示使用该模式。
* UNSPECIFIED 无限大测量模式，只有在绘制特定自定义View时才用的到这个模式。

真正代表测量结束的方法是setMeasuredDimension方法，该方法传入的两个参数是宽高的SpecSize。测量结束后我们可以通过getMeasureHeight和getMeasureWidth来获取测量宽高。

**自定义ViewGroup一定要重写onMeasure方法，用于测量子View的宽高，不重写的话子View没有宽高。**

自定义View如果在xml中使用了wrap_content属性，就需要重写onMeasure方法来设置wrap_content的默认大小，不然会显示出match_parent的效果。

###layout的过程：
ViewGroup用来将子View放在合适的位置上。</br>
layout是从ViewRoot类中的host.layout开始的，内部调用的是ViewGroup的layout方法。在ViewGroup的layout方法中，先调用setFrame来确定自己的左上右下的位置，再调用onLayout来确定子View的位置。</br>
**自定义ViewGroup一定要重写layout方法来确定子View的位置，自定义View一般不需要重写该方法，它的位置是右父控件确定的。**

###draw过程:
此过程是真正将内容展示在屏幕上让我们能够看到的过程。</br>
draw是从ViewRoot类中的host.draw开始的，内部调用的是View的draw方法。</br>
draw的步骤：

1. 绘制背景。
2. 绘制内容，也就是调用onDraw方法。
3. 绘制子View，调用的是dispatchDraw方法。
4. 绘制装饰，如listview的滚动条等。

对于View的绘制过程，既可以说是简单的，也可以说是复杂的，简单的在于Google已经帮我们将draw框架写好了，我们在自定义ViewGroup时不用管draw过程，只需要实现measure和layout过程。复杂在于，我们写继承View的自定义控件的时候需要重写onDraw方法，这样才能绘制出你自定义的View的内容，onDraw（Canvas canvas）方法中最重要的两个东西是Paint和Canvas，这个使用起来算是比较复杂的。

##<a name="view_draw_process_2"/>安卓view绘制机制和加载过程，请详细说下整个流程
* 1.ViewRootImpl会调用performTraversals(),其内部会调用performMeasure()、performLayout、performDraw()。
* 2.performMeasure()会调用最外层的ViewGroup的measure()-->onMeasure(),ViewGroup的onMeasure()是抽象方法，但其提供了measureChildren()，这之中会遍历子View然后循环调用measureChild()这之中会用getChildMeasureSpec()+父View的MeasureSpec+子View的LayoutParam一起获取本View的MeasureSpec，然后调用子View的measure()到View的onMeasure()-->setMeasureDimension(getDefaultSize(),getDefaultSize()),getDefaultSize()默认返回measureSpec的测量数值，所以继承View进行自定义的wrap_content需要重写。
* performLayout()会调用最外层的ViewGroup的layout(l,t,r,b),本View在其中使用setFrame()设置本View的四个顶点位置。在onLayout(抽象方法)中确定子View的位置，如LinearLayout会遍历子View，循环调用setChildFrame()-->子View.layout()。
* performDraw()会调用最外层ViewGroup的draw():其中会先后调用background.draw()(绘制背景)、onDraw()(绘制自己)、dispatchDraw()(绘制子View)、onDrawScrollBars()(绘制装饰)。
* 5.MeasureSpec由2位SpecMode(UNSPECIFIED、EXACTLY(对应精确值和match_parent)、AT_MOST(对应warp_content))和30位SpecSize组成一个int,DecorView的MeasureSpec由窗口大小和其LayoutParams决定，其他View由父View的MeasureSpec和本View的LayoutParams决定。ViewGroup中有getChildMeasureSpec()来获取子View的MeasureSpec。
* 6.三种方式获取measure()后的宽高：
	* 1.Activity#onWindowFocusChange()中调用获取
	* 2.view.post(Runnable)将获取的代码投递到消息队列的尾部。
	* 3.ViewTreeObservable.





##<a name="define_view_adapter"/>自定义View如何考虑机型适配
这里要考虑的是屏幕的问题：

* 合理使用warp_content，match_parent.
* 尽可能的是使用RelativeLayout
* 针对不同的机型，使用不同的布局文件放在对应的目录下，android会自动匹配。
* 尽量使用点9图片。
* 使用与密度无关的像素单位dp，sp
* 引入android的百分比布局。
* 切图的时候切大分辨率的图，应用到布局当中。在小分辨率的手机上也会有很好的显示效果。


##<a name="android_touch_event"/>请描述一下Android 的事件分发机制；

* 主要涉及到以下三个方法:
	* public boolean dispatchTouchEvent(MotionEvent ev); 这个方法用来进行事件的分发
	* public boolean onInterceptTouchEvent(MotionEvent ev); 这个方法用来判断是否拦截事件
	* onTouchEvent(MotionEvent ev); 这个方法用来处理点击事件。		
* 点击事件的传递规则： 
	* 对于一个根ViewGroup，点击事件产生后，首先会传递给他，这时候就会调用他的onDispatchTouchEvent方法，如果Viewgroup的onInterceptTouchEvent方法返回true表示他要拦截事件，接下来事件就会交给ViewGroup处理，调用ViewGroup的onTouchEvent方法；如果ViewGroup的onInteceptTouchEvent方法返回值为false，表示ViewGroup不拦截该事件，这时事件就传递给他的子View，接下来子View的dispatchTouchEvent方法，如此反复直到事件被最终处理。
	* 当一个View需要处理事件时，如果它设置了OnTouchListener，那么onTouch方法会被调用，如果onTouch返回false，则当前View的onTouchEvent方法会被调用，返回true则不会被调用，同时，在onTouchEvent方法中如果设置了OnClickListener，那么他的onClick方法会被调用。由此可见处理事件时的优先级关系： onTouchListener > onTouchEvent > onClickListener.
* 事件传递的机制，一些结论:
	1. 一个事件系列以down事件开始,中间包含数量不定的move事件,最终以up事件结束.
	2. 正常情况下,一个事件序列只能由一个View拦截并消耗。
	3. 某个View拦截了事件后,该事件序列只能由它去处理,并且它的onInterceptTouchEvent不会再被调用.
	4. 某个View一旦开始处理事件,如果它不消耗ACTION_DOWN事件（onTouchEvnet返回false）,那么同一事件序列中的其他事件都不会交给他处理，并且事件将重新交由他的父元素去处理,即父元素的onTouchEvent被调用.
	5. 如果View不消耗ACTION_DOWN以外的其他事件,那么这个事件将会消失,此时父元素的onTouchEvent并不会被调用,并且当前View可以持续收到后续的事件,最终消失的点击事件会传递给Activity去处理.
	6. ViewGroup默认不拦截任何事件.
	7. View没有onInterceptTouchEvent方法,一旦事件传递给它,它的onTouchEvent方法会被调用.
	8. View的onTouchEvent默认消耗事件,除非他是不可点击的（clickable和longClickable同时为false）.
	9. onClick会发生的前提是当前View是可点击的,并且收到了down和up事件.
	10. 事件传递过程总是由外向内的,即事件总是先传递给父元素,然后由父元素分发给子View,通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的分发过程,但是ACTION_DOWN事件除外.
	11. 具体可参考:[View的事件体系(四)View 的事件分发机制](http://www.jianshu.com/p/804eb1a5dd13)

##<a name="android_touch_event_2"/>Touch事件分发机制；
一个完整的touch事件，由一个down事件，多个move事件，一个up事件组成。</br>
Touch事件的一般传递流程Activity-->window(唯一实现类PhoneWindow)-->顶级View(DecorView)-->ViewGroup-->View</br>
监听Touch事件有两种方式，setOnTouchListener和直接重写三个方法：dispatchTouchEvent,onInterceptTouchEvent,onTouchEvent。</br>
使用setOnTouchListenre方式设置监听事件，该方式的优先级较高，如果在onTouchListener的onTouch方法中return true的话，那么onTouchEvent方法是接收不到该Touch事件的。而且因为onClickListener中的onClick方法实际上是在onTouchEvent中被调用的，所以Touch事件走不到onTouchEvent，Touch事件就不会生效。

直接重写三个方法：

* dispatchTouchEvent：该方法是对点击事件的分发，在这个方法中我们一般return super.dispatchTouchEvent,讲该事件分发下去。
* onInterceptTouchEvent：该方法表示对Touch事件进行拦截，这是ViewGroup特有的方法，View没有。在ViewGroup中如果onInterceptTouchEvent返回true，表示将该事件拦截，那么事件将传递给ViewGroup的* onTouchEvent方法处理。如果onInterceptTouchEvent方法返回true，事件将传递个子View的dispatchTouchEvent进行分发。
* onTouchEvent:该方法表示对Touch事件进行消费，返回true表现消费，返回false表示不消费，那么该事件该事件将传递给父控件的onTouchEvent处理。

![](../images/mianshi/android_touch_event.png)

##<a name="android_handler_loop"/>Handler、Loop消息队列模型，各部分的作用
* MessageQueue：读取会自动删除消息，单链表维护，在插入和删除上有优势。在其next()中会无限循环，不断判断是否有消息，有就返回这条消息并移除。
* Looper：Looper创建的时候会创建一个MessageQueue，调用loop()方法的时候消息循环开始，loop()也是一个死循环，会不断调用messageQueue的next()，当有消息就处理，否则阻塞在messageQueue的next()中。当Looper的quit()被调用的时候会调用messageQueue的quit(),此时next()会返回null，然后loop()方法也跟着退出。
* Handler：在主线程构造一个Handler，然后在其他线程调用sendMessage(),此时主线程的MessageQueue中会插入一条message，然后被Looper使用。
* 系统的主线程在ActivityThread的main()为入口开启主线程，其中定义了内部类Activity.H定义了一系列消息类型，包含四大组件的启动停止。


##<a name="android_ipc_binder"/>Android IPC:Binder原理
* 1.在Activity和Service进行通讯的时候，用到了Binder。
	* 1.当属于同个进程我们可以继承Binder然后在Activity中对Service进行操作
	* 2.当不属于同个进程，那么要用到AIDL让系统给我们创建一个Binder，然后在Activity中对远端的Service进行操作。
* 2.系统给我们生成的Binder：
	*  1.Stub类中有:接口方法的id，有该Binder的标识，有asInterface(IBinder)(让我们在Activity中获取实现了Binder的接口，接口的实现在Service里，同进程时候返回Stub否则返回Proxy)，有onTransact()这个方法是在不同进程的时候让Proxy在Activity进行远端调用实现Activity操作Service
	*  2.Proxy类是代理，在Activity端，其中有:IBinder mRemote(这就是远端的Binder)，两个接口的实现方法不过是代理最终还是要在远端的onTransact()中进行实际操作。
* 3.哪一端的Binder是副本，该端就可以被另一端进行操作，因为Binder本体在定义的时候可以操作本端的东西。所以可以在Activity端传入本端的Binder，让Service端对其进行操作称为Listener，可以用RemoteCallbackList这个容器来装Listener，防止Listener因为经历过序列化而产生的问题。
* 4.当Activity端向远端进行调用的时候，当前线程会挂起，当方法处理完毕才会唤醒。
* 5.如果一个AIDL就用一个Service太奢侈，所以可以使用Binder池的方式，建立一个AIDL其中的方法是返回IBinder，然后根据方法中传入的参数返回具体的AIDL。
* 6.IPC的方式有：
	* Bundle（在Intent启动的时候传入，不过是一次性的），
	* 文件共享(对于SharedPreference是特例，因为其在内存中会有缓存)，
	* 使用Messenger(其底层用的也是AIDL，同理要操作哪端，就在哪端定义Messenger)，
	* AIDL，
	* ContentProvider(在本进程中继承实现一个ContentProvider，在增删改查方法中调用本进程的SQLite，在其他进程中查询)，
	* Socket



## <a name="android_binder"/>Binder机制
Binder包含四个角色：

* Server 服务器
* Client 客户终端 
	* 获得实名Binder的引用。Server向ServiceManger注册了Binder实体及名字后，Client就可以通过名字获得该Binder的引用。例如我们申请获得名字叫张三的Binder的引用，ServiceManager收到这个连接请求，从请求数据包里获得Binder的名字。再找到该名字对应的条目，从条目中取出Binder的引用。将该引用作为回复发送给发起请求的Client。
* ServiceManager 域名服务器（DNS），负责将字符形式的Binder名字转化成Client中对该Binder的应用，使得Client能通过Binder名字获得Server中Binder实体的引用。
* Binder驱动 可以理解为路由器。Binder驱动负责进程之间Binder通信的建立，Binder在进程间的传递。

Binder使用Client-Server通信方式，安全性好，简单高效。再加上其面向对象的设计思想，独特的接收缓存管理和线程池管理方式，成为Android进程间通信的中流砥柱。

## <a name="android_application_activity_context"/>ApplicationContext和ActivityContext的区别；
这是两种不同的context，也是最常见的两种.

* 第一种中context的生命周期与Application的生命周期相关的，context随着Application的销毁而销毁，伴随application的一生，与activity的生命周期无关.
* 第二种中的context跟Activity的生命周期是相关的，但是对一个Application来说，Activity可以销毁几次，那么属于Activity的context就会销毁多次
* 至于用哪种context，得看应用场景，个人感觉用Activity的context好一点，不过也有的时候必须使用Application的context.application context

##<a name="application_activity_context"/>Android中的Context, Activity，Appliction有什么区别?
* 相同：Activity和Application都是Context的子类。
	* Context从字面上理解就是上下文的意思，在实际应用中它也确实是起到了管理上下文环境中各个参数和变量的总用，方便我们可以简单的访问到各种资源。
* 不同：维护的生命周期不同。 Context维护的是当前的Activity的生命周期，Application维护的是整个项目的生命周期。
* 使用context的时候，小心内存泄露，防止内存泄露，注意一下几个方面：
	* 1. 不要让生命周期长的对象引用activity context，即保证引用activity的对象要与activity本身生命周期是一样的。
	* 2. 对于生命周期长的对象，可以使用application，context。
	* 3. 避免非静态的内部类，尽量使用静态类，避免生命周期问题，注意内部类对外部对象引用导致的生命周期变化。


## <a name="Serializable_Parcelable"/>Serializable 和Parcelable 的区别
在Android上应该尽量采用Parcelable，它效率更高。</br>
Parcelabe代码比Serializable多一些。</br>
Parcelabe比Serializable速度高十倍以上。</br>
Serializable只需要对某个类以及它的属性实现Serializable接口即可，无需实现方法。缺点是使用的反射，序列化的过程较慢，这种机制会在序列化的时候创建许多的临时对象。容易触发GC。</br>
Parcable方法实现的原理是将一根完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样也就实现传递对象的功能。

在使用内存的时候，Parcelable 类比 Serializable 性能高，所以推荐使用 Parcelable 类。

1. Serializable 在序列化的时候会产生大量的临时变量，从而引起频繁的 GC。
2. Parcelable 不能使用在要将数据存储在磁盘上的情况。尽管 Serializable 效率低点，但在这种情况下，还是建议你用 Serializable 。

###通过Intent传递一些二进制数据的方法有哪些?
* 使用Serializable接口实现序列化，这是Java常用的方法。
* 实现Parcelable接口，这里Android的部分类比如Bitmap类就已经实现了，同时Parcelable在Android AIDL中交换数据也很常见的。


## <a name="introduce_ndk"/>介绍一下NDK;
###一 ： NDK是一系列工具的集合
NDK提供了一系列的工具，帮助开发者快速开发C或C++的动态库，并能自动将so和java应用一起打包成apk。这些工具对开发者的帮助是巨大的。</br>
NDK集成了交叉编译器，并提供了相应的mk文件隔离CPU，平台，ABI等差异。开发人员只需要简单修改mk文件（指出哪些文件需要编译，编译特性要求等）就可以创建出so。</br>
NDK可以自动将so和java应用一起打包，极大的减轻了开发人员的打包工作。
###二 ： NDK提供了一份稳定，功能有限的API头文件声明。
Google明确声明该API是稳定的，在后续所有版本中都稳定支持当前发布的API。从该版本的NDK中看出，这些API支持的功能非常有限，包含：c标准库，标准数学库，压缩库，Log库。


##<a name="LruCache"/>说说LruCache 底层原理
LruCache 使用一个 LinkedHashMap 简单的实现内存的缓存，没有软引用，都是强引用。如果添加的数据大于设置的最大值，就删除最先缓存的数据来调整内存。</br>
maxSize 是通过构造方法初始化的值，他表示这个缓存能缓存的最大值是多少。</br>
size 在添加和移除缓存都被更新值，他通过 safeSizeOf 这个方法更新值。safeSizeOf 默认返回 1，但一般我们会根据 maxSize 重写这个方法，比如认为 maxSize 代表是 KB 的话，那么就以 KB 为单位返回该项所占的内存大小。</br>
除异常外首先会判断 size 是否超过 maxSize，如果超过了就取出最先插入的缓存，如果不为空就删掉，并把 size 减去该项所占的大小。这个操作将一直循环下去，直到 size 比 maxSize 小或者缓存为空。



-------


#系统方面

##<a name="activity_start_mode"/>activity的启动流程
App启动过程：[Activity启动过程详解](http://blog.csdn.net/stonecao/article/details/6591847)

从桌面点击到activity启动的过程

1. Launcher线程捕获onclick的点击事件，调用Launcher.startActivitySafely,进一步调用Launcher.startActivity，最后调用父类Activity的startActivity。
2. Activity和ActivityManagerService交互，引入Instrumentation，将启动请求交给Instrumentation，调用Instrumentation.execStartActivity。
3. 调用ActivityManagerService的startActivity方法，这里做了进程切换（具体过程请查看源码）。
4. 开启Activity，调用onCreate方法


##<a name="art_and_dalvik"/>ART和Dalvik区别? 
* art上应用启动快，运行快，但是耗费更多存储空间，安装时间长，总的来说ART的功效就是”空间换时间”。
ART: Ahead of TimeDalvik: Just in Time什么是Dalvik：Dalvik是Google公司自己设计用于Android平台的Java虚拟机。
* Dalvik虚拟机是Google等厂商合作开发的Android移动设备平台的核心组成部分之一，它可以支持已转换为.dex(即Dalvik Executable)格式的Java应用程序的运行，.dex格式是专为Dalvik应用设计的一种压缩格式，适合内存和处理器速度有限的系统。
Dalvik经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik应用作为独立的Linux进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。
###什么是ART?
Android操作系统已经成熟，Google的Android团队开始将注意力转向一些底层组件，其中之一是负责应用程序运行的Dalvik运行时。Google开发者已经花了两年时间开发更快执行效率更高更省电的替代ART运行时。ART代表Android Runtime,其处理应用程序执行的方式完全不同于Dalvik.

Dalvik是依靠一个Just-In-Time(JIT)编译器去解释字节码。开发者编译后的应用代码需要通过一个解释器在用户的设备上运行，这一机制并不高效，但让应用能更容易在不同硬件和架构上运行。ART则完全改变了这套做法，在应用安装的时候就预编译字节码到机器语言，这一机制叫Ahead-Of-Time(AOT)编译。在移除解释代码这一过程后，应用程序执行将更有效率，启动更快。
###ART优点：
系统性能的显著提升应用启动更快、运行更快、体验更流畅、触感反馈更及时。更长的电池续航能力支持更低的硬件
###ART缺点：
更大的存储空间占用，可能会增加10%-20%更长的应用安装时间.

答案2

在程序运行过程中Dalvik虚拟机不断的进行将字节码转换为机器码的工作。
而Art引入了AOT这种预编译技术，在应用程序的安装过程中已经将所有的字节码编译为了机器码，在运行的时候直接调用。Art极大的提高了程序的运行效率，同时减少了手机的耗电量，在垃圾回收机制上也有很大的优化，但是Art模式下应用程序的安装需要消耗更多的时间，同时也需要跟多的安装空间。

* Dalvik 是Android4.4及以下平台的虚拟机。
* Art 是在Android4.4以上平台使用的虚拟机。

##<a name="art_and_dalvik"/>JVM 和Dalvik虚拟机的区别
* JVM:.java -> javac -> .class -> jar -> .jar架构: 堆和栈的架构.
* DVM:.java -> javac -> .class -> dx.bat -> .dex架构: 寄存器(cpu上的一块高速缓存)

#框架原理
## <a name="butterKnife"/>ButterKnife原理
ButterKnife对性能的影响很小，因为没有使用使用反射，而是使用的**Annotation Processing Tool(APT)**，注解处理器，javac中用于编译时扫描和解析Java注解的工具。

在编译阶段执行的，它的原理就是读入Java源代码，解析注解，然后生成新的Java代码。
新生成的Java代码最后被编译成Java字节码，注解解析器不能改变读入的Java 类，比如不能加入或删除Java方法。

## <a name="butterKnife"/>插件化（activity如何加载及资源处理）
Activity使用占坑hook加载,也可以使用静态代理，静态代理就需要自定义classloader,记住这个加载模式就行，资源处理就是assetmanager的创建，然后资源冲突处理，简单的可以构建多个assetmanager就没有冲突问题，应为隔离了，如果使用一个那么打包aapt定制一下就行

调用onCreate方法热补丁原因：

因为一个dvm中存储方法id用的是short类型，导致dex中方法不能超过65536个原理：将编译好的class文件拆分打包成两个dex，绕过dex方法数量的限制以及安装时的检查，在运行时再动态加载第二个dex文件中。使用Dexclassloader。

动态加载(也叫插件化技术)动态加载主要解决3个技术问题：

1. 使用ClassLoader加载类。
2. 资源访问。
3. 生命周期管理。

参考

1. [Android*动态*加载学习总结（一）：类加载器](
2. ://www.jianshu.com/p/ecfc7fe9d9f8)
2. [ZeusPlugin:掌*阅Android App插件补丁实践*](http://www.jianshu.com/p/b1e7b6326330)
3. [Android 插件*化原理解析*——Hook机制之AMS&PMS](http://www.jianshu.com/p/8632fdc86009)
4. [Android Hotfix 新*方案*——Amigo 源码解读](http://www.jianshu.com/p/cba95a8b33e5)
5. [Android Hotfix 新*方案*——Amigo 源码解读](http://www.jianshu.com/p/6f687dec55e4)


##<a name="android_important_word"/>android重要术语解释
* 1.ActivityManagerServices，简称AMS，服务端对象，负责系统中所有Activity的生命周期
* 2.ActivityThread，App的真正入口。当开启App之后，会调用main()开始运行，开启消息循环队列，这就是传说中的UI线程或者叫主线程。与ActivityManagerServices配合，一起完成Activity的管理工作
* 3.ApplicationThread，用来实现ActivityManagerService与ActivityThread之间的交互。在ActivityManagerService需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通讯。
* 3.ApplicationThread，用来实现ActivityManagerService与ActivityThread之间的交互。在ActivityManagerService需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通讯。
* 4.ApplicationThreadProxy，是ApplicationThread在服务器端的代理，负责和客户端的ApplicationThread通讯。AMS就是通过该代理与ActivityThread进行通信的。
* 5.Instrumentation，每一个应用程序只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。Instrumentation可以理解为应用进程的管家，ActivityThread要创建或暂停某个Activity时，都需要通过Instrumentation来进行具体的操作。
* 6.ActivityStack，Activity在AMS的栈管理，用来记录已经启动的Activity的先后关系，状态信息等。通过ActivityStack决定是否需要启动新的进程。
* 7.ActivityRecord，ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，来记录Activity的状态以及其他的管理信息。其实就是服务器端的Activity对象的映像。
* 8.TaskRecord，AMS抽象出来的一个“任务”的概念，是记录ActivityRecord的栈，一个“Task”包含若干个ActivityRecord。AMS用TaskRecord确保Activity启动和退出的顺序。如果你清楚Activity的4种launchMode，那么对这个概念应该不陌生。


##<a name="window_windowManager"/>理解Window和WindowManager
* 1.Window用于显示View和接收各种事件，Window有三种类型：应用Window(每个Activity对应一个Window)、子Window(不能单独存在，附属于特定Window)、系统window(Toast和状态栏)
* 2.Window分层级，应用Window在1-99、子Window在1000-1999、系统Window在2000-2999.WindowManager提供了增删改View三个功能。
* 3.Window是个抽象概念：每一个Window对应着一个View和ViewRootImpl，Window通过ViewRootImpl来和View建立联系，View是Window存在的实体，只能通过WindowManager来访问Window。
* 4.WindowManager的实现是WindowManagerImpl其再委托给WindowManagerGlobal来对Window进行操作，其中有四个List分别储存对应的View、ViewRootImpl、WindowManger.LayoutParams和正在被删除的View
* 5.Window的实体是存在于远端的WindowMangerService中，所以增删改Window在本端是修改上面的几个List然后通过ViewRootImpl重绘View，通过WindowSession(每个应用一个)在远端修改Window。
* 6.Activity创建Window：Activity会在attach()中创建Window并设置其回调(onAttachedToWindow()、dispatchTouchEvent()),Activity的Window是由Policy类创建PhoneWindow实现的。然后通过Activity#setContentView()调用PhoneWindow的setContentView。





#优秀文章
* <a name="android_memory_leake"/>Android 内存泄漏总结[https://juejin.im/entry/56d64b9e816dfa005943a55c](https://juejin.im/entry/56d64b9e816dfa005943a55c)
* https 与 http  [http://www.jianshu.com/p/93fdebe5fef1](http://www.jianshu.com/p/93fdebe5fef1)
* Java设计模式- Singleton  [http://www.jianshu.com/p/a956024629cb](http://www.jianshu.com/p/a956024629cb)
* Android主流IOC框架浅析 [http://www.jianshu.com/p/3968ffabdf9d](http://www.jianshu.com/p/3968ffabdf9d)



#性能优化
* Android性能优化之如何避免Overdraw [http://www.jianshu.com/p/145fc61011cd](http://www.jianshu.com/p/145fc61011cd)
* android数据库优化 [http://www.jianshu.com/p/3b4452fc1bbd](http://www.jianshu.com/p/3b4452fc1bbd)
* Android APP内存优化之图片优化 [http://www.jianshu.com/p/5bb8c01e2bc7](http://www.jianshu.com/p/5bb8c01e2bc7)
* Android网络请求心路历程 [http://www.jianshu.com/p/3141d4e46240](http://www.jianshu.com/p/3141d4e46240)

##性能优化
* 界面优化太多重叠的背景(overdraw)这个问题其实最容易解决，建议就是检查你在布局和代码中设置的背景，有些背景是隐藏在底下的，它永远不可能显示出来，这种没必要的背景一定要移除，因为它很可能会严重影响到app的性能。如果采用的是selector的背景，将normal状态的color设置为”@android:color/transparent”,也同样可以解决问题。
* 太多重叠的View第一个建议是 ：使用ViewStub来加载一些不常用的布局，它是一个轻量级且默认是不可见的视图，可以动态的加载一个布局，只要你用到这个重叠着的View的时候才加载，推迟加载的时间。
* 第二个建议是：如果使用了类似Viewpager＋Fragment这样的组合或者有多个Fragment在一个界面上，需要控制Fragment的显示和隐藏，尽量使用动态的Inflation view，它的性能要比SetVisibility好。
* 复杂的Layout层级这里的建议比较多一些，首先推荐使用Android提供的布局工具Hierarchy Viewer来检查和优化布局。
	* 第一个建议是：如果嵌套的线性布局加深了布局层次，可以使用相对布局来取代。
	* 第二个建议是：用标签来合并布局。
	* 第三个建议是：用标签来重用布局，抽取通用的布局可以让布局的逻辑更清晰明了。

记住，这些建议的最终目的都是使得你的Layout在Hierarchy Viewer里变得宽而浅，而不是窄而深。

###总结：
* 可以考虑多使用merge和include，ViewStub。
* 尽量使布局浅平，根布局尽量少使用RelactivityLayout,因为RelactivityLayout每次需要测量2次。
* 内存优化核心思想：减少内存使用，能不new的不new，能少分配的少分配。因为分配更多的内存就意味着发生更多的GC，每次触发GC都会占用CPU时间，影响性能。
* 集合优化：Android提供了一系列优化过后的数据集合工具类，如SparseArray、SparseBooleanArray、LongSparseArray，使用这些API可以让我们的程序更加高效。
* HashMap工具类会相对比较低效，因为它需要为每一个键值对都提供一个对象入口，而SparseArray就避免掉了基本数据类型转换成对象数据类型的时间。
* Bitmap优化：读取一个Bitmap图片的时候，千万不要去加载不需要的分辨率。可以压缩图片等操作。
* 尽量避免使用依赖注入框架。
* 避免创作不必要的对象：字符串拼接使用StringBuffer，StringBuilder。
* onDraw方法里面不要执行对象的创建.重写onTrimMemory，根据传入的参数，进行内存释放。
* 使用static final 优化成员变量。
* 移动端获取网络数据优化的几个点连接复用：
	* 节省连接建立时间，如开启 keep-alive。对于Android来说默认情况下HttpURLConnection和HttpClient都开启了keep-alive。只是2.2之前HttpURLConnection存在影响连接池的Bug，具体可见：Android HttpURLConnection及HttpClient选择请求合并：即将多个请求合并为一个进行请求，比较常见的就是网页中的CSS Image Sprites。如果某个页面内请求过多，也可以考虑做一定的请求合并。
	* 减少请求数据的大小：对于post请求，body可以做gzip压缩的，header也可以做数据压缩(不过只支持http 2.0)。返回数据的body也可以做gzip压缩，body数据体积可以缩小到原来的30%左右。（也可以考虑压缩返回的json数据的key数据的体积，尤其是针对返回数据格式变化不大的情况，支付宝聊天返回的数据用到了）根据用户的当前的网络质量来判断下载什么质量的图片（电商用的比较多）.